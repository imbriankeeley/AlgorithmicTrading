"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/papaparse@5.5.1";
exports.ids = ["vendor-chunks/papaparse@5.5.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/papaparse@5.5.1/node_modules/papaparse/papaparse.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/papaparse@5.5.1/node_modules/papaparse/papaparse.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/* @license\nPapa Parse\nv5.5.1\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/ (function(root, factory) {\n    /* globals define */ if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n// in strict mode we cannot access arguments.callee, so we need a named reference to\n// stringify the factory method for the blob worker\n// eslint-disable-next-line func-name\n})(void 0, function moduleFactory() {\n    \"use strict\";\n    var global = function() {\n        // alternative method, similar to `Function('return this')()`\n        // but without using `eval` (which is disabled when\n        // using Content Security Policy).\n        if (typeof self !== \"undefined\") {\n            return self;\n        }\n        if (false) {}\n        if (typeof global !== \"undefined\") {\n            return global;\n        }\n        // When running tests none of the above have been defined\n        return {};\n    }();\n    function getWorkerBlob() {\n        var URL = global.URL || global.webkitURL || null;\n        var code = moduleFactory.toString();\n        return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob([\n            \"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\n            \"(\",\n            code,\n            \")();\"\n        ], {\n            type: \"text/javascript\"\n        })));\n    }\n    var IS_WORKER = !global.document && !!global.postMessage, IS_PAPA_WORKER = global.IS_PAPA_WORKER || false;\n    var workers = {}, workerIdCounter = 0;\n    var Papa = {};\n    Papa.parse = CsvToJson;\n    Papa.unparse = JsonToCsv;\n    Papa.RECORD_SEP = String.fromCharCode(30);\n    Papa.UNIT_SEP = String.fromCharCode(31);\n    Papa.BYTE_ORDER_MARK = \"\\uFEFF\";\n    Papa.BAD_DELIMITERS = [\n        \"\\r\",\n        \"\\n\",\n        '\"',\n        Papa.BYTE_ORDER_MARK\n    ];\n    Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n    Papa.NODE_STREAM_INPUT = 1;\n    // Configurable chunk sizes for local and remote files, respectively\n    Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\n    Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\n    Papa.DefaultDelimiter = \",\"; // Used if not specified and detection fails\n    // Exposed for testing and development only\n    Papa.Parser = Parser;\n    Papa.ParserHandle = ParserHandle;\n    Papa.NetworkStreamer = NetworkStreamer;\n    Papa.FileStreamer = FileStreamer;\n    Papa.StringStreamer = StringStreamer;\n    Papa.ReadableStreamStreamer = ReadableStreamStreamer;\n    if (typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n        Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n    }\n    if (global.jQuery) {\n        var $ = global.jQuery;\n        $.fn.parse = function(options) {\n            var config = options.config || {};\n            var queue = [];\n            this.each(function(idx) {\n                var supported = $(this).prop(\"tagName\").toUpperCase() === \"INPUT\" && $(this).attr(\"type\").toLowerCase() === \"file\" && global.FileReader;\n                if (!supported || !this.files || this.files.length === 0) return true; // continue to next input element\n                for(var i = 0; i < this.files.length; i++){\n                    queue.push({\n                        file: this.files[i],\n                        inputElem: this,\n                        instanceConfig: $.extend({}, config)\n                    });\n                }\n            });\n            parseNextFile(); // begin parsing\n            return this; // maintains chainability\n            function parseNextFile() {\n                if (queue.length === 0) {\n                    if (isFunction(options.complete)) options.complete();\n                    return;\n                }\n                var f = queue[0];\n                if (isFunction(options.before)) {\n                    var returned = options.before(f.file, f.inputElem);\n                    if (typeof returned === \"object\") {\n                        if (returned.action === \"abort\") {\n                            error(\"AbortError\", f.file, f.inputElem, returned.reason);\n                            return; // Aborts all queued files immediately\n                        } else if (returned.action === \"skip\") {\n                            fileComplete(); // parse the next file in the queue, if any\n                            return;\n                        } else if (typeof returned.config === \"object\") f.instanceConfig = $.extend(f.instanceConfig, returned.config);\n                    } else if (returned === \"skip\") {\n                        fileComplete(); // parse the next file in the queue, if any\n                        return;\n                    }\n                }\n                // Wrap up the user's complete callback, if any, so that ours also gets executed\n                var userCompleteFunc = f.instanceConfig.complete;\n                f.instanceConfig.complete = function(results) {\n                    if (isFunction(userCompleteFunc)) userCompleteFunc(results, f.file, f.inputElem);\n                    fileComplete();\n                };\n                Papa.parse(f.file, f.instanceConfig);\n            }\n            function error(name, file, elem, reason) {\n                if (isFunction(options.error)) options.error({\n                    name: name\n                }, file, elem, reason);\n            }\n            function fileComplete() {\n                queue.splice(0, 1);\n                parseNextFile();\n            }\n        };\n    }\n    if (IS_PAPA_WORKER) {\n        global.onmessage = workerThreadReceivedMessage;\n    }\n    function CsvToJson(_input, _config) {\n        _config = _config || {};\n        var dynamicTyping = _config.dynamicTyping || false;\n        if (isFunction(dynamicTyping)) {\n            _config.dynamicTypingFunction = dynamicTyping;\n            // Will be filled on first row call\n            dynamicTyping = {};\n        }\n        _config.dynamicTyping = dynamicTyping;\n        _config.transform = isFunction(_config.transform) ? _config.transform : false;\n        if (_config.worker && Papa.WORKERS_SUPPORTED) {\n            var w = newWorker();\n            w.userStep = _config.step;\n            w.userChunk = _config.chunk;\n            w.userComplete = _config.complete;\n            w.userError = _config.error;\n            _config.step = isFunction(_config.step);\n            _config.chunk = isFunction(_config.chunk);\n            _config.complete = isFunction(_config.complete);\n            _config.error = isFunction(_config.error);\n            delete _config.worker; // prevent infinite loop\n            w.postMessage({\n                input: _input,\n                config: _config,\n                workerId: w.id\n            });\n            return;\n        }\n        var streamer = null;\n        if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n            // create a node Duplex stream for use\n            // with .pipe\n            streamer = new DuplexStreamStreamer(_config);\n            return streamer.getStream();\n        } else if (typeof _input === \"string\") {\n            _input = stripBom(_input);\n            if (_config.download) streamer = new NetworkStreamer(_config);\n            else streamer = new StringStreamer(_config);\n        } else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n            streamer = new ReadableStreamStreamer(_config);\n        } else if (global.File && _input instanceof File || _input instanceof Object) streamer = new FileStreamer(_config);\n        return streamer.stream(_input);\n        // Strip character from UTF-8 BOM encoded files that cause issue parsing the file\n        function stripBom(string) {\n            if (string.charCodeAt(0) === 0xfeff) {\n                return string.slice(1);\n            }\n            return string;\n        }\n    }\n    function JsonToCsv(_input, _config) {\n        // Default configuration\n        /** whether to surround every datum with quotes */ var _quotes = false;\n        /** whether to write headers */ var _writeHeader = true;\n        /** delimiting character(s) */ var _delimiter = \",\";\n        /** newline character(s) */ var _newline = \"\\r\\n\";\n        /** quote character */ var _quoteChar = '\"';\n        /** escaped quote character, either \"\" or <config.escapeChar>\" */ var _escapedQuote = _quoteChar + _quoteChar;\n        /** whether to skip empty lines */ var _skipEmptyLines = false;\n        /** the columns (keys) we expect when we unparse objects */ var _columns = null;\n        /** whether to prevent outputting cells that can be parsed as formulae by spreadsheet software (Excel and LibreOffice) */ var _escapeFormulae = false;\n        unpackConfig();\n        var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), \"g\");\n        if (typeof _input === \"string\") _input = JSON.parse(_input);\n        if (Array.isArray(_input)) {\n            if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);\n            else if (typeof _input[0] === \"object\") return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);\n        } else if (typeof _input === \"object\") {\n            if (typeof _input.data === \"string\") _input.data = JSON.parse(_input.data);\n            if (Array.isArray(_input.data)) {\n                if (!_input.fields) _input.fields = _input.meta && _input.meta.fields || _columns;\n                if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : typeof _input.data[0] === \"object\" ? Object.keys(_input.data[0]) : [];\n                if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== \"object\") _input.data = [\n                    _input.data\n                ]; // handles input like [1,2,3] or ['asdf']\n            }\n            return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n        }\n        // Default (any valid paths should return before this)\n        throw new Error(\"Unable to serialize unrecognized input\");\n        function unpackConfig() {\n            if (typeof _config !== \"object\") return;\n            if (typeof _config.delimiter === \"string\" && !Papa.BAD_DELIMITERS.filter(function(value) {\n                return _config.delimiter.indexOf(value) !== -1;\n            }).length) {\n                _delimiter = _config.delimiter;\n            }\n            if (typeof _config.quotes === \"boolean\" || typeof _config.quotes === \"function\" || Array.isArray(_config.quotes)) _quotes = _config.quotes;\n            if (typeof _config.skipEmptyLines === \"boolean\" || typeof _config.skipEmptyLines === \"string\") _skipEmptyLines = _config.skipEmptyLines;\n            if (typeof _config.newline === \"string\") _newline = _config.newline;\n            if (typeof _config.quoteChar === \"string\") _quoteChar = _config.quoteChar;\n            if (typeof _config.header === \"boolean\") _writeHeader = _config.header;\n            if (Array.isArray(_config.columns)) {\n                if (_config.columns.length === 0) throw new Error(\"Option columns is empty\");\n                _columns = _config.columns;\n            }\n            if (_config.escapeChar !== undefined) {\n                _escapedQuote = _config.escapeChar + _quoteChar;\n            }\n            if (_config.escapeFormulae instanceof RegExp) {\n                _escapeFormulae = _config.escapeFormulae;\n            } else if (typeof _config.escapeFormulae === \"boolean\" && _config.escapeFormulae) {\n                _escapeFormulae = /^[=+\\-@\\t\\r].*$/;\n            }\n        }\n        /** The double for loop that iterates the data and writes out a CSV string including header row */ function serialize(fields, data, skipEmptyLines) {\n            var csv = \"\";\n            if (typeof fields === \"string\") fields = JSON.parse(fields);\n            if (typeof data === \"string\") data = JSON.parse(data);\n            var hasHeader = Array.isArray(fields) && fields.length > 0;\n            var dataKeyedByField = !Array.isArray(data[0]);\n            // If there a header row, write it first\n            if (hasHeader && _writeHeader) {\n                for(var i = 0; i < fields.length; i++){\n                    if (i > 0) csv += _delimiter;\n                    csv += safe(fields[i], i);\n                }\n                if (data.length > 0) csv += _newline;\n            }\n            // Then write out the data\n            for(var row = 0; row < data.length; row++){\n                var maxCol = hasHeader ? fields.length : data[row].length;\n                var emptyLine = false;\n                var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n                if (skipEmptyLines && !hasHeader) {\n                    emptyLine = skipEmptyLines === \"greedy\" ? data[row].join(\"\").trim() === \"\" : data[row].length === 1 && data[row][0].length === 0;\n                }\n                if (skipEmptyLines === \"greedy\" && hasHeader) {\n                    var line = [];\n                    for(var c = 0; c < maxCol; c++){\n                        var cx = dataKeyedByField ? fields[c] : c;\n                        line.push(data[row][cx]);\n                    }\n                    emptyLine = line.join(\"\").trim() === \"\";\n                }\n                if (!emptyLine) {\n                    for(var col = 0; col < maxCol; col++){\n                        if (col > 0 && !nullLine) csv += _delimiter;\n                        var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n                        csv += safe(data[row][colIdx], col);\n                    }\n                    if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {\n                        csv += _newline;\n                    }\n                }\n            }\n            return csv;\n        }\n        /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */ function safe(str, col) {\n            if (typeof str === \"undefined\" || str === null) return \"\";\n            if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n            var needsQuotes = false;\n            if (_escapeFormulae && typeof str === \"string\" && _escapeFormulae.test(str)) {\n                str = \"'\" + str;\n                needsQuotes = true;\n            }\n            var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n            needsQuotes = needsQuotes || _quotes === true || typeof _quotes === \"function\" && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === \" \" || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === \" \";\n            return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n        }\n        function hasAny(str, substrings) {\n            for(var i = 0; i < substrings.length; i++)if (str.indexOf(substrings[i]) > -1) return true;\n            return false;\n        }\n    }\n    /** ChunkStreamer is the base prototype for various streamer implementations. */ function ChunkStreamer(config) {\n        this._handle = null;\n        this._finished = false;\n        this._completed = false;\n        this._halted = false;\n        this._input = null;\n        this._baseIndex = 0;\n        this._partialLine = \"\";\n        this._rowCount = 0;\n        this._start = 0;\n        this._nextChunk = null;\n        this.isFirstChunk = true;\n        this._completeResults = {\n            data: [],\n            errors: [],\n            meta: {}\n        };\n        replaceConfig.call(this, config);\n        this.parseChunk = function(chunk, isFakeChunk) {\n            // First chunk pre-processing\n            const skipFirstNLines = parseInt(this._config.skipFirstNLines) || 0;\n            if (this.isFirstChunk && skipFirstNLines > 0) {\n                let _newline = this._config.newline;\n                if (!_newline) {\n                    const quoteChar = this._config.quoteChar || '\"';\n                    _newline = this._handle.guessLineEndings(chunk, quoteChar);\n                }\n                const splitChunk = chunk.split(_newline);\n                chunk = [\n                    ...splitChunk.slice(skipFirstNLines)\n                ].join(_newline);\n            }\n            if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n                var modifiedChunk = this._config.beforeFirstChunk(chunk);\n                if (modifiedChunk !== undefined) chunk = modifiedChunk;\n            }\n            this.isFirstChunk = false;\n            this._halted = false;\n            // Rejoin the line we likely just split in two by chunking the file\n            var aggregate = this._partialLine + chunk;\n            this._partialLine = \"\";\n            var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n            if (this._handle.paused() || this._handle.aborted()) {\n                this._halted = true;\n                return;\n            }\n            var lastIndex = results.meta.cursor;\n            if (!this._finished) {\n                this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n                this._baseIndex = lastIndex;\n            }\n            if (results && results.data) this._rowCount += results.data.length;\n            var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;\n            if (IS_PAPA_WORKER) {\n                global.postMessage({\n                    results: results,\n                    workerId: Papa.WORKER_ID,\n                    finished: finishedIncludingPreview\n                });\n            } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n                this._config.chunk(results, this._handle);\n                if (this._handle.paused() || this._handle.aborted()) {\n                    this._halted = true;\n                    return;\n                }\n                results = undefined;\n                this._completeResults = undefined;\n            }\n            if (!this._config.step && !this._config.chunk) {\n                this._completeResults.data = this._completeResults.data.concat(results.data);\n                this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n                this._completeResults.meta = results.meta;\n            }\n            if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n                this._config.complete(this._completeResults, this._input);\n                this._completed = true;\n            }\n            if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n            return results;\n        };\n        this._sendError = function(error) {\n            if (isFunction(this._config.error)) this._config.error(error);\n            else if (IS_PAPA_WORKER && this._config.error) {\n                global.postMessage({\n                    workerId: Papa.WORKER_ID,\n                    error: error,\n                    finished: false\n                });\n            }\n        };\n        function replaceConfig(config) {\n            // Deep-copy the config so we can edit it\n            var configCopy = copy(config);\n            configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n            if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n            this._handle = new ParserHandle(configCopy);\n            this._handle.streamer = this;\n            this._config = configCopy; // persist the copy to the caller\n        }\n    }\n    function NetworkStreamer(config) {\n        config = config || {};\n        if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n        ChunkStreamer.call(this, config);\n        var xhr;\n        if (IS_WORKER) {\n            this._nextChunk = function() {\n                this._readChunk();\n                this._chunkLoaded();\n            };\n        } else {\n            this._nextChunk = function() {\n                this._readChunk();\n            };\n        }\n        this.stream = function(url) {\n            this._input = url;\n            this._nextChunk(); // Starts streaming\n        };\n        this._readChunk = function() {\n            if (this._finished) {\n                this._chunkLoaded();\n                return;\n            }\n            xhr = new XMLHttpRequest();\n            if (this._config.withCredentials) {\n                xhr.withCredentials = this._config.withCredentials;\n            }\n            if (!IS_WORKER) {\n                xhr.onload = bindFunction(this._chunkLoaded, this);\n                xhr.onerror = bindFunction(this._chunkError, this);\n            }\n            xhr.open(this._config.downloadRequestBody ? \"POST\" : \"GET\", this._input, !IS_WORKER);\n            // Headers can only be set when once the request state is OPENED\n            if (this._config.downloadRequestHeaders) {\n                var headers = this._config.downloadRequestHeaders;\n                for(var headerName in headers){\n                    xhr.setRequestHeader(headerName, headers[headerName]);\n                }\n            }\n            if (this._config.chunkSize) {\n                var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + this._start + \"-\" + end);\n            }\n            try {\n                xhr.send(this._config.downloadRequestBody);\n            } catch (err) {\n                this._chunkError(err.message);\n            }\n            if (IS_WORKER && xhr.status === 0) this._chunkError();\n        };\n        this._chunkLoaded = function() {\n            if (xhr.readyState !== 4) return;\n            if (xhr.status < 200 || xhr.status >= 400) {\n                this._chunkError();\n                return;\n            }\n            // Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n            this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n            this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n            this.parseChunk(xhr.responseText);\n        };\n        this._chunkError = function(errorMessage) {\n            var errorText = xhr.statusText || errorMessage;\n            this._sendError(new Error(errorText));\n        };\n        function getFileSize(xhr) {\n            var contentRange = xhr.getResponseHeader(\"Content-Range\");\n            if (contentRange === null) {\n                return -1;\n            }\n            return parseInt(contentRange.substring(contentRange.lastIndexOf(\"/\") + 1));\n        }\n    }\n    NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    NetworkStreamer.prototype.constructor = NetworkStreamer;\n    function FileStreamer(config) {\n        config = config || {};\n        if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n        ChunkStreamer.call(this, config);\n        var reader, slice;\n        // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n        // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n        var usingAsyncReader = typeof FileReader !== \"undefined\"; // Safari doesn't consider it a function - see issue #105\n        this.stream = function(file) {\n            this._input = file;\n            slice = file.slice || file.webkitSlice || file.mozSlice;\n            if (usingAsyncReader) {\n                reader = new FileReader(); // Preferred method of reading files, even in workers\n                reader.onload = bindFunction(this._chunkLoaded, this);\n                reader.onerror = bindFunction(this._chunkError, this);\n            } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n            this._nextChunk(); // Starts streaming\n        };\n        this._nextChunk = function() {\n            if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview)) this._readChunk();\n        };\n        this._readChunk = function() {\n            var input = this._input;\n            if (this._config.chunkSize) {\n                var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n                input = slice.call(input, this._start, end);\n            }\n            var txt = reader.readAsText(input, this._config.encoding);\n            if (!usingAsyncReader) this._chunkLoaded({\n                target: {\n                    result: txt\n                }\n            }); // mimic the async signature\n        };\n        this._chunkLoaded = function(event) {\n            // Very important to increment start each time before handling results\n            this._start += this._config.chunkSize;\n            this._finished = !this._config.chunkSize || this._start >= this._input.size;\n            this.parseChunk(event.target.result);\n        };\n        this._chunkError = function() {\n            this._sendError(reader.error);\n        };\n    }\n    FileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    FileStreamer.prototype.constructor = FileStreamer;\n    function StringStreamer(config) {\n        config = config || {};\n        ChunkStreamer.call(this, config);\n        var remaining;\n        this.stream = function(s) {\n            remaining = s;\n            return this._nextChunk();\n        };\n        this._nextChunk = function() {\n            if (this._finished) return;\n            var size = this._config.chunkSize;\n            var chunk;\n            if (size) {\n                chunk = remaining.substring(0, size);\n                remaining = remaining.substring(size);\n            } else {\n                chunk = remaining;\n                remaining = \"\";\n            }\n            this._finished = !remaining;\n            return this.parseChunk(chunk);\n        };\n    }\n    StringStreamer.prototype = Object.create(StringStreamer.prototype);\n    StringStreamer.prototype.constructor = StringStreamer;\n    function ReadableStreamStreamer(config) {\n        config = config || {};\n        ChunkStreamer.call(this, config);\n        var queue = [];\n        var parseOnData = true;\n        var streamHasEnded = false;\n        this.pause = function() {\n            ChunkStreamer.prototype.pause.apply(this, arguments);\n            this._input.pause();\n        };\n        this.resume = function() {\n            ChunkStreamer.prototype.resume.apply(this, arguments);\n            this._input.resume();\n        };\n        this.stream = function(stream) {\n            this._input = stream;\n            this._input.on(\"data\", this._streamData);\n            this._input.on(\"end\", this._streamEnd);\n            this._input.on(\"error\", this._streamError);\n        };\n        this._checkIsFinished = function() {\n            if (streamHasEnded && queue.length === 1) {\n                this._finished = true;\n            }\n        };\n        this._nextChunk = function() {\n            this._checkIsFinished();\n            if (queue.length) {\n                this.parseChunk(queue.shift());\n            } else {\n                parseOnData = true;\n            }\n        };\n        this._streamData = bindFunction(function(chunk) {\n            try {\n                queue.push(typeof chunk === \"string\" ? chunk : chunk.toString(this._config.encoding));\n                if (parseOnData) {\n                    parseOnData = false;\n                    this._checkIsFinished();\n                    this.parseChunk(queue.shift());\n                }\n            } catch (error) {\n                this._streamError(error);\n            }\n        }, this);\n        this._streamError = bindFunction(function(error) {\n            this._streamCleanUp();\n            this._sendError(error);\n        }, this);\n        this._streamEnd = bindFunction(function() {\n            this._streamCleanUp();\n            streamHasEnded = true;\n            this._streamData(\"\");\n        }, this);\n        this._streamCleanUp = bindFunction(function() {\n            this._input.removeListener(\"data\", this._streamData);\n            this._input.removeListener(\"end\", this._streamEnd);\n            this._input.removeListener(\"error\", this._streamError);\n        }, this);\n    }\n    ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n    function DuplexStreamStreamer(_config) {\n        var Duplex = (__webpack_require__(/*! stream */ \"stream\").Duplex);\n        var config = copy(_config);\n        var parseOnWrite = true;\n        var writeStreamHasFinished = false;\n        var parseCallbackQueue = [];\n        var stream = null;\n        this._onCsvData = function(results) {\n            var data = results.data;\n            if (!stream.push(data) && !this._handle.paused()) {\n                // the writeable consumer buffer has filled up\n                // so we need to pause until more items\n                // can be processed\n                this._handle.pause();\n            }\n        };\n        this._onCsvComplete = function() {\n            // node will finish the read stream when\n            // null is pushed\n            stream.push(null);\n        };\n        config.step = bindFunction(this._onCsvData, this);\n        config.complete = bindFunction(this._onCsvComplete, this);\n        ChunkStreamer.call(this, config);\n        this._nextChunk = function() {\n            if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n                this._finished = true;\n            }\n            if (parseCallbackQueue.length) {\n                parseCallbackQueue.shift()();\n            } else {\n                parseOnWrite = true;\n            }\n        };\n        this._addToParseQueue = function(chunk, callback) {\n            // add to queue so that we can indicate\n            // completion via callback\n            // node will automatically pause the incoming stream\n            // when too many items have been added without their\n            // callback being invoked\n            parseCallbackQueue.push(bindFunction(function() {\n                this.parseChunk(typeof chunk === \"string\" ? chunk : chunk.toString(config.encoding));\n                if (isFunction(callback)) {\n                    return callback();\n                }\n            }, this));\n            if (parseOnWrite) {\n                parseOnWrite = false;\n                this._nextChunk();\n            }\n        };\n        this._onRead = function() {\n            if (this._handle.paused()) {\n                // the writeable consumer can handle more data\n                // so resume the chunk parsing\n                this._handle.resume();\n            }\n        };\n        this._onWrite = function(chunk, encoding, callback) {\n            this._addToParseQueue(chunk, callback);\n        };\n        this._onWriteComplete = function() {\n            writeStreamHasFinished = true;\n            // have to write empty string\n            // so parser knows its done\n            this._addToParseQueue(\"\");\n        };\n        this.getStream = function() {\n            return stream;\n        };\n        stream = new Duplex({\n            readableObjectMode: true,\n            decodeStrings: false,\n            read: bindFunction(this._onRead, this),\n            write: bindFunction(this._onWrite, this)\n        });\n        stream.once(\"finish\", bindFunction(this._onWriteComplete, this));\n    }\n    if (typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n        DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n        DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n    }\n    // Use one ParserHandle per entire CSV file or string\n    function ParserHandle(_config) {\n        // One goal is to minimize the use of regular expressions...\n        var MAX_FLOAT = Math.pow(2, 53);\n        var MIN_FLOAT = -MAX_FLOAT;\n        var FLOAT = /^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/;\n        var ISO_DATE = /^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/;\n        var self1 = this;\n        var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n        var _rowCounter = 0; // Number of rows that have been parsed so far\n        var _input; // The input being parsed\n        var _parser; // The core parser being used\n        var _paused = false; // Whether we are paused or not\n        var _aborted = false; // Whether the parser has aborted or not\n        var _delimiterError; // Temporary state between delimiter detection and processing results\n        var _fields = []; // Fields are from the header row of the input, if there is one\n        var _results = {\n            data: [],\n            errors: [],\n            meta: {}\n        };\n        if (isFunction(_config.step)) {\n            var userStep = _config.step;\n            _config.step = function(results) {\n                _results = results;\n                if (needsHeaderRow()) processResults();\n                else {\n                    processResults();\n                    // It's possbile that this line was empty and there's no row here after all\n                    if (_results.data.length === 0) return;\n                    _stepCounter += results.data.length;\n                    if (_config.preview && _stepCounter > _config.preview) _parser.abort();\n                    else {\n                        _results.data = _results.data[0];\n                        userStep(_results, self1);\n                    }\n                }\n            };\n        }\n        /**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */ this.parse = function(input, baseIndex, ignoreLastRow) {\n            var quoteChar = _config.quoteChar || '\"';\n            if (!_config.newline) _config.newline = this.guessLineEndings(input, quoteChar);\n            _delimiterError = false;\n            if (!_config.delimiter) {\n                var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n                if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;\n                else {\n                    _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n                    _config.delimiter = Papa.DefaultDelimiter;\n                }\n                _results.meta.delimiter = _config.delimiter;\n            } else if (isFunction(_config.delimiter)) {\n                _config.delimiter = _config.delimiter(input);\n                _results.meta.delimiter = _config.delimiter;\n            }\n            var parserConfig = copy(_config);\n            if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n            _input = input;\n            _parser = new Parser(parserConfig);\n            _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n            processResults();\n            return _paused ? {\n                meta: {\n                    paused: true\n                }\n            } : _results || {\n                meta: {\n                    paused: false\n                }\n            };\n        };\n        this.paused = function() {\n            return _paused;\n        };\n        this.pause = function() {\n            _paused = true;\n            _parser.abort();\n            // If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n            // otherwise we can get duplicate content within a row\n            _input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n        };\n        this.resume = function() {\n            if (self1.streamer._halted) {\n                _paused = false;\n                self1.streamer.parseChunk(_input, true);\n            } else {\n                // Bugfix: #636 In case the processing hasn't halted yet\n                // wait for it to halt in order to resume\n                setTimeout(self1.resume, 3);\n            }\n        };\n        this.aborted = function() {\n            return _aborted;\n        };\n        this.abort = function() {\n            _aborted = true;\n            _parser.abort();\n            _results.meta.aborted = true;\n            if (isFunction(_config.complete)) _config.complete(_results);\n            _input = \"\";\n        };\n        this.guessLineEndings = function(input, quoteChar) {\n            input = input.substring(0, 1024 * 1024); // max length 1 MB\n            // Replace all the text inside quotes\n            var re = new RegExp(escapeRegExp(quoteChar) + \"([^]*?)\" + escapeRegExp(quoteChar), \"gm\");\n            input = input.replace(re, \"\");\n            var r = input.split(\"\\r\");\n            var n = input.split(\"\\n\");\n            var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n            if (r.length === 1 || nAppearsFirst) return \"\\n\";\n            var numWithN = 0;\n            for(var i = 0; i < r.length; i++){\n                if (r[i][0] === \"\\n\") numWithN++;\n            }\n            return numWithN >= r.length / 2 ? \"\\r\\n\" : \"\\r\";\n        };\n        function testEmptyLine(s) {\n            return _config.skipEmptyLines === \"greedy\" ? s.join(\"\").trim() === \"\" : s.length === 1 && s[0].length === 0;\n        }\n        function testFloat(s) {\n            if (FLOAT.test(s)) {\n                var floatValue = parseFloat(s);\n                if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function processResults() {\n            if (_results && _delimiterError) {\n                addError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\");\n                _delimiterError = false;\n            }\n            if (_config.skipEmptyLines) {\n                _results.data = _results.data.filter(function(d) {\n                    return !testEmptyLine(d);\n                });\n            }\n            if (needsHeaderRow()) fillHeaderFields();\n            return applyHeaderAndDynamicTypingAndTransformation();\n        }\n        function needsHeaderRow() {\n            return _config.header && _fields.length === 0;\n        }\n        function fillHeaderFields() {\n            if (!_results) return;\n            function addHeader(header, i) {\n                if (isFunction(_config.transformHeader)) header = _config.transformHeader(header, i);\n                _fields.push(header);\n            }\n            if (Array.isArray(_results.data[0])) {\n                for(var i = 0; needsHeaderRow() && i < _results.data.length; i++)_results.data[i].forEach(addHeader);\n                _results.data.splice(0, 1);\n            } else _results.data.forEach(addHeader);\n        }\n        function shouldApplyDynamicTyping(field) {\n            // Cache function values to avoid calling it for each row\n            if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n                _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n            }\n            return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n        }\n        function parseDynamic(field, value) {\n            if (shouldApplyDynamicTyping(field)) {\n                if (value === \"true\" || value === \"TRUE\") return true;\n                else if (value === \"false\" || value === \"FALSE\") return false;\n                else if (testFloat(value)) return parseFloat(value);\n                else if (ISO_DATE.test(value)) return new Date(value);\n                else return value === \"\" ? null : value;\n            }\n            return value;\n        }\n        function applyHeaderAndDynamicTypingAndTransformation() {\n            if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;\n            function processRow(rowSource, i) {\n                var row = _config.header ? {} : [];\n                var j;\n                for(j = 0; j < rowSource.length; j++){\n                    var field = j;\n                    var value = rowSource[j];\n                    if (_config.header) field = j >= _fields.length ? \"__parsed_extra\" : _fields[j];\n                    if (_config.transform) value = _config.transform(value, field);\n                    value = parseDynamic(field, value);\n                    if (field === \"__parsed_extra\") {\n                        row[field] = row[field] || [];\n                        row[field].push(value);\n                    } else row[field] = value;\n                }\n                if (_config.header) {\n                    if (j > _fields.length) addError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, _rowCounter + i);\n                    else if (j < _fields.length) addError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, _rowCounter + i);\n                }\n                return row;\n            }\n            var incrementBy = 1;\n            if (!_results.data.length || Array.isArray(_results.data[0])) {\n                _results.data = _results.data.map(processRow);\n                incrementBy = _results.data.length;\n            } else _results.data = processRow(_results.data, 0);\n            if (_config.header && _results.meta) _results.meta.fields = _fields;\n            _rowCounter += incrementBy;\n            return _results;\n        }\n        function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n            var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n            delimitersToGuess = delimitersToGuess || [\n                \",\",\n                \"\t\",\n                \"|\",\n                \";\",\n                Papa.RECORD_SEP,\n                Papa.UNIT_SEP\n            ];\n            for(var i = 0; i < delimitersToGuess.length; i++){\n                var delim = delimitersToGuess[i];\n                var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n                fieldCountPrevRow = undefined;\n                var preview = new Parser({\n                    comments: comments,\n                    delimiter: delim,\n                    newline: newline,\n                    preview: 10\n                }).parse(input);\n                for(var j = 0; j < preview.data.length; j++){\n                    if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n                        emptyLinesCount++;\n                        continue;\n                    }\n                    var fieldCount = preview.data[j].length;\n                    avgFieldCount += fieldCount;\n                    if (typeof fieldCountPrevRow === \"undefined\") {\n                        fieldCountPrevRow = fieldCount;\n                        continue;\n                    } else if (fieldCount > 0) {\n                        delta += Math.abs(fieldCount - fieldCountPrevRow);\n                        fieldCountPrevRow = fieldCount;\n                    }\n                }\n                if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n                if ((typeof bestDelta === \"undefined\" || delta <= bestDelta) && (typeof maxFieldCount === \"undefined\" || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n                    bestDelta = delta;\n                    bestDelim = delim;\n                    maxFieldCount = avgFieldCount;\n                }\n            }\n            _config.delimiter = bestDelim;\n            return {\n                successful: !!bestDelim,\n                bestDelimiter: bestDelim\n            };\n        }\n        function addError(type, code, msg, row) {\n            var error = {\n                type: type,\n                code: code,\n                message: msg\n            };\n            if (row !== undefined) {\n                error.row = row;\n            }\n            _results.errors.push(error);\n        }\n    }\n    /** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */ function escapeRegExp(string) {\n        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n    }\n    /** The core parser implements speedy and correct CSV parsing */ function Parser(config) {\n        // Unpack the config object\n        config = config || {};\n        var delim = config.delimiter;\n        var newline = config.newline;\n        var comments = config.comments;\n        var step = config.step;\n        var preview = config.preview;\n        var fastMode = config.fastMode;\n        var quoteChar;\n        var renamedHeaders = null;\n        if (config.quoteChar === undefined || config.quoteChar === null) {\n            quoteChar = '\"';\n        } else {\n            quoteChar = config.quoteChar;\n        }\n        var escapeChar = quoteChar;\n        if (config.escapeChar !== undefined) {\n            escapeChar = config.escapeChar;\n        }\n        // Delimiter must be valid\n        if (typeof delim !== \"string\" || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = \",\";\n        // Comment character must be valid\n        if (comments === delim) throw new Error(\"Comment character same as delimiter\");\n        else if (comments === true) comments = \"#\";\n        else if (typeof comments !== \"string\" || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false;\n        // Newline must be valid: \\r, \\n, or \\r\\n\n        if (newline !== \"\\n\" && newline !== \"\\r\" && newline !== \"\\r\\n\") newline = \"\\n\";\n        // We're gonna need these at the Parser scope\n        var cursor = 0;\n        var aborted = false;\n        this.parse = function(input, baseIndex, ignoreLastRow) {\n            // For some reason, in Chrome, this speeds things up (!?)\n            if (typeof input !== \"string\") throw new Error(\"Input must be a string\");\n            // We don't need to compute some of these every time parse() is called,\n            // but having them in a more local scope seems to perform better\n            var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;\n            var stepIsFunction = isFunction(step);\n            // Establish starting state\n            cursor = 0;\n            var data = [], errors = [], row = [], lastCursor = 0;\n            if (!input) return returnable();\n            if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {\n                var rows = input.split(newline);\n                for(var i = 0; i < rows.length; i++){\n                    row = rows[i];\n                    cursor += row.length;\n                    if (i !== rows.length - 1) cursor += newline.length;\n                    else if (ignoreLastRow) return returnable();\n                    if (comments && row.substring(0, commentsLen) === comments) continue;\n                    if (stepIsFunction) {\n                        data = [];\n                        pushRow(row.split(delim));\n                        doStep();\n                        if (aborted) return returnable();\n                    } else pushRow(row.split(delim));\n                    if (preview && i >= preview) {\n                        data = data.slice(0, preview);\n                        return returnable(true);\n                    }\n                }\n                return returnable();\n            }\n            var nextDelim = input.indexOf(delim, cursor);\n            var nextNewline = input.indexOf(newline, cursor);\n            var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), \"g\");\n            var quoteSearch = input.indexOf(quoteChar, cursor);\n            // Parser loop\n            for(;;){\n                // Field has opening quote\n                if (input[cursor] === quoteChar) {\n                    // Start our search for the closing quote where the cursor is\n                    quoteSearch = cursor;\n                    // Skip the opening quote\n                    cursor++;\n                    for(;;){\n                        // Find closing quote\n                        quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n                        //No other quotes are found - no other delimiters\n                        if (quoteSearch === -1) {\n                            if (!ignoreLastRow) {\n                                // No closing quote... what a pity\n                                errors.push({\n                                    type: \"Quotes\",\n                                    code: \"MissingQuotes\",\n                                    message: \"Quoted field unterminated\",\n                                    row: data.length,\n                                    index: cursor\n                                });\n                            }\n                            return finish();\n                        }\n                        // Closing quote at EOF\n                        if (quoteSearch === inputLen - 1) {\n                            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n                            return finish(value);\n                        }\n                        // If this quote is escaped, it's part of the data; skip it\n                        // If the quote character is the escape character, then check if the next character is the escape character\n                        if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n                            quoteSearch++;\n                            continue;\n                        }\n                        // If the quote character is not the escape character, then check if the previous character was the escape character\n                        if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {\n                            continue;\n                        }\n                        if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {\n                            nextDelim = input.indexOf(delim, quoteSearch + 1);\n                        }\n                        if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {\n                            nextNewline = input.indexOf(newline, quoteSearch + 1);\n                        }\n                        // Check up to nextDelim or nextNewline, whichever is closest\n                        var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n                        var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n                        // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n                        if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim) {\n                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n                            // If char after following delimiter is not quoteChar, we find next quote char position\n                            if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {\n                                quoteSearch = input.indexOf(quoteChar, cursor);\n                            }\n                            nextDelim = input.indexOf(delim, cursor);\n                            nextNewline = input.indexOf(newline, cursor);\n                            break;\n                        }\n                        var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n                        // Closing quote followed by newline or 'unnecessary spaces + newLine'\n                        if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {\n                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n                            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n                            quoteSearch = input.indexOf(quoteChar, cursor); // we search for first quote in next line\n                            if (stepIsFunction) {\n                                doStep();\n                                if (aborted) return returnable();\n                            }\n                            if (preview && data.length >= preview) return returnable(true);\n                            break;\n                        }\n                        // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n                        errors.push({\n                            type: \"Quotes\",\n                            code: \"InvalidQuotes\",\n                            message: \"Trailing quote on quoted field is malformed\",\n                            row: data.length,\n                            index: cursor\n                        });\n                        quoteSearch++;\n                        continue;\n                    }\n                    continue;\n                }\n                // Comment found at start of new line\n                if (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {\n                    if (nextNewline === -1) return returnable();\n                    cursor = nextNewline + newlineLen;\n                    nextNewline = input.indexOf(newline, cursor);\n                    nextDelim = input.indexOf(delim, cursor);\n                    continue;\n                }\n                // Next delimiter comes before next newline, so we've reached end of field\n                if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n                    row.push(input.substring(cursor, nextDelim));\n                    cursor = nextDelim + delimLen;\n                    // we look for next delimiter char\n                    nextDelim = input.indexOf(delim, cursor);\n                    continue;\n                }\n                // End of row\n                if (nextNewline !== -1) {\n                    row.push(input.substring(cursor, nextNewline));\n                    saveRow(nextNewline + newlineLen);\n                    if (stepIsFunction) {\n                        doStep();\n                        if (aborted) return returnable();\n                    }\n                    if (preview && data.length >= preview) return returnable(true);\n                    continue;\n                }\n                break;\n            }\n            return finish();\n            function pushRow(row) {\n                data.push(row);\n                lastCursor = cursor;\n            }\n            /**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */ function extraSpaces(index) {\n                var spaceLength = 0;\n                if (index !== -1) {\n                    var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n                    if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === \"\") {\n                        spaceLength = textBetweenClosingQuoteAndIndex.length;\n                    }\n                }\n                return spaceLength;\n            }\n            /**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */ function finish(value) {\n                if (ignoreLastRow) return returnable();\n                if (typeof value === \"undefined\") value = input.substring(cursor);\n                row.push(value);\n                cursor = inputLen; // important in case parsing is paused\n                pushRow(row);\n                if (stepIsFunction) doStep();\n                return returnable();\n            }\n            /**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */ function saveRow(newCursor) {\n                cursor = newCursor;\n                pushRow(row);\n                row = [];\n                nextNewline = input.indexOf(newline, cursor);\n            }\n            /** Returns an object with the results, errors, and meta. */ function returnable(stopped) {\n                if (config.header && !baseIndex && data.length) {\n                    const result = data[0];\n                    const headerCount = {}; // To track the count of each base header\n                    const usedHeaders = new Set(result); // To track used headers and avoid duplicates\n                    let duplicateHeaders = false;\n                    for(let i = 0; i < result.length; i++){\n                        let header = result[i];\n                        if (isFunction(config.transformHeader)) header = config.transformHeader(header, i);\n                        if (!headerCount[header]) {\n                            headerCount[header] = 1;\n                            result[i] = header;\n                        } else {\n                            let newHeader;\n                            let suffixCount = headerCount[header];\n                            // Find a unique new header\n                            do {\n                                newHeader = `${header}_${suffixCount}`;\n                                suffixCount++;\n                            }while (usedHeaders.has(newHeader));\n                            usedHeaders.add(newHeader); // Mark this new Header as used\n                            result[i] = newHeader;\n                            headerCount[header]++;\n                            duplicateHeaders = true;\n                            if (renamedHeaders === null) {\n                                renamedHeaders = {};\n                            }\n                            renamedHeaders[newHeader] = header;\n                        }\n                        usedHeaders.add(header); // Ensure the original header is marked as used\n                    }\n                    if (duplicateHeaders) {\n                        console.warn(\"Duplicate headers found and renamed.\");\n                    }\n                }\n                return {\n                    data: data,\n                    errors: errors,\n                    meta: {\n                        delimiter: delim,\n                        linebreak: newline,\n                        aborted: aborted,\n                        truncated: !!stopped,\n                        cursor: lastCursor + (baseIndex || 0),\n                        renamedHeaders: renamedHeaders\n                    }\n                };\n            }\n            /** Executes the user's step function and resets data & errors. */ function doStep() {\n                step(returnable());\n                data = [];\n                errors = [];\n            }\n        };\n        /** Sets the abort flag */ this.abort = function() {\n            aborted = true;\n        };\n        /** Gets the cursor position */ this.getCharIndex = function() {\n            return cursor;\n        };\n    }\n    function newWorker() {\n        if (!Papa.WORKERS_SUPPORTED) return false;\n        var workerUrl = getWorkerBlob();\n        var w = new global.Worker(workerUrl);\n        w.onmessage = mainThreadReceivedMessage;\n        w.id = workerIdCounter++;\n        workers[w.id] = w;\n        return w;\n    }\n    /** Callback when main thread receives a message */ function mainThreadReceivedMessage(e) {\n        var msg = e.data;\n        var worker = workers[msg.workerId];\n        var aborted = false;\n        if (msg.error) worker.userError(msg.error, msg.file);\n        else if (msg.results && msg.results.data) {\n            var abort = function() {\n                aborted = true;\n                completeWorker(msg.workerId, {\n                    data: [],\n                    errors: [],\n                    meta: {\n                        aborted: true\n                    }\n                });\n            };\n            var handle = {\n                abort: abort,\n                pause: notImplemented,\n                resume: notImplemented\n            };\n            if (isFunction(worker.userStep)) {\n                for(var i = 0; i < msg.results.data.length; i++){\n                    worker.userStep({\n                        data: msg.results.data[i],\n                        errors: msg.results.errors,\n                        meta: msg.results.meta\n                    }, handle);\n                    if (aborted) break;\n                }\n                delete msg.results; // free memory ASAP\n            } else if (isFunction(worker.userChunk)) {\n                worker.userChunk(msg.results, handle, msg.file);\n                delete msg.results;\n            }\n        }\n        if (msg.finished && !aborted) completeWorker(msg.workerId, msg.results);\n    }\n    function completeWorker(workerId, results) {\n        var worker = workers[workerId];\n        if (isFunction(worker.userComplete)) worker.userComplete(results);\n        worker.terminate();\n        delete workers[workerId];\n    }\n    function notImplemented() {\n        throw new Error(\"Not implemented.\");\n    }\n    /** Callback when worker thread receives a message */ function workerThreadReceivedMessage(e) {\n        var msg = e.data;\n        if (typeof Papa.WORKER_ID === \"undefined\" && msg) Papa.WORKER_ID = msg.workerId;\n        if (typeof msg.input === \"string\") {\n            global.postMessage({\n                workerId: Papa.WORKER_ID,\n                results: Papa.parse(msg.input, msg.config),\n                finished: true\n            });\n        } else if (global.File && msg.input instanceof File || msg.input instanceof Object) {\n            var results = Papa.parse(msg.input, msg.config);\n            if (results) global.postMessage({\n                workerId: Papa.WORKER_ID,\n                results: results,\n                finished: true\n            });\n        }\n    }\n    /** Makes a deep copy of an array or object (mostly) */ function copy(obj) {\n        if (typeof obj !== \"object\" || obj === null) return obj;\n        var cpy = Array.isArray(obj) ? [] : {};\n        for(var key in obj)cpy[key] = copy(obj[key]);\n        return cpy;\n    }\n    function bindFunction(f, self1) {\n        return function() {\n            f.apply(self1, arguments);\n        };\n    }\n    function isFunction(func) {\n        return typeof func === \"function\";\n    }\n    return Papa;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcGFwYXBhcnNlQDUuNS4xL25vZGVfbW9kdWxlcy9wYXBhcGFyc2UvcGFwYXBhcnNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7QUFLQSxHQUVDLFVBQVNBLElBQUksRUFBRUMsT0FBTztJQUV0QixrQkFBa0IsR0FDbEIsSUFBSSxJQUEwQyxFQUM5QztRQUNDLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxvQ0FBRUQsT0FBT0E7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3BCLE9BQ0ssRUFXSjtBQUNELG9GQUFvRjtBQUNwRixtREFBbUQ7QUFDbkQscUNBQXFDO0FBQ3RDLEdBQUUsUUFBTSxTQUFTTTtJQUVoQjtJQUVBLElBQUlDLFNBQVM7UUFDWiw2REFBNkQ7UUFDN0QsbURBQW1EO1FBQ25ELGtDQUFrQztRQUVsQyxJQUFJLE9BQU9DLFNBQVMsYUFBYTtZQUFFLE9BQU9BO1FBQU07UUFDaEQsSUFBSSxLQUFrQixFQUFhLEVBQWtCO1FBQ3JELElBQUksT0FBT0QsV0FBVyxhQUFhO1lBQUUsT0FBT0E7UUFBUTtRQUVwRCx5REFBeUQ7UUFDekQsT0FBTyxDQUFDO0lBQ1Q7SUFHQSxTQUFTRztRQUNSLElBQUlDLE1BQU1KLE9BQU9JLEdBQUcsSUFBSUosT0FBT0ssU0FBUyxJQUFJO1FBQzVDLElBQUlDLE9BQU9QLGNBQWNRLFFBQVE7UUFDakMsT0FBT1QsS0FBS1UsUUFBUSxJQUFLVixDQUFBQSxLQUFLVSxRQUFRLEdBQUdKLElBQUlLLGVBQWUsQ0FBQyxJQUFJQyxLQUFLO1lBQUM7WUFBME87WUFBS0o7WUFBTTtTQUFPLEVBQUU7WUFBQ0ssTUFBTTtRQUFpQixHQUFFO0lBQ2hXO0lBRUEsSUFBSUMsWUFBWSxDQUFDWixPQUFPYSxRQUFRLElBQUksQ0FBQyxDQUFDYixPQUFPYyxXQUFXLEVBQ3ZEQyxpQkFBaUJmLE9BQU9lLGNBQWMsSUFBSTtJQUUzQyxJQUFJQyxVQUFVLENBQUMsR0FBR0Msa0JBQWtCO0lBRXBD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QUcsQ0FBQztRQUNyQyxJQUFLLElBQUlFLE9BQU9GLElBQ2ZDLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHN0wsS0FBSzJMLEdBQUcsQ0FBQ0UsSUFBSTtRQUN6QixPQUFPRDtJQUNSO0lBRUEsU0FBU25MLGFBQWF2SixDQUFDLEVBQUVsRSxLQUFJO1FBRTVCLE9BQU87WUFBYWtFLEVBQUVtTSxLQUFLLENBQUNyUSxPQUFNc1E7UUFBWTtJQUMvQztJQUNBLFNBQVN0TSxXQUFXOFUsSUFBSTtRQUV2QixPQUFPLE9BQU9BLFNBQVM7SUFDeEI7SUFFQSxPQUFPalo7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyeXB0by10cmFkaW5nLWJvdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9wYXBhcGFyc2VANS41LjEvbm9kZV9tb2R1bGVzL3BhcGFwYXJzZS9wYXBhcGFyc2UuanM/MDNkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAbGljZW5zZVxuUGFwYSBQYXJzZVxudjUuNS4xXG5odHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlXG5MaWNlbnNlOiBNSVRcbiovXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KVxue1xuXHQvKiBnbG9iYWxzIGRlZmluZSAqL1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHR7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKVxuXHR7XG5cdFx0Ly8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG5cdFx0Ly8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG5cdFx0Ly8gbGlrZSBOb2RlLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG5cdFx0cm9vdC5QYXBhID0gZmFjdG9yeSgpO1xuXHR9XG5cdC8vIGluIHN0cmljdCBtb2RlIHdlIGNhbm5vdCBhY2Nlc3MgYXJndW1lbnRzLmNhbGxlZSwgc28gd2UgbmVlZCBhIG5hbWVkIHJlZmVyZW5jZSB0b1xuXHQvLyBzdHJpbmdpZnkgdGhlIGZhY3RvcnkgbWV0aG9kIGZvciB0aGUgYmxvYiB3b3JrZXJcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZVxufSh0aGlzLCBmdW5jdGlvbiBtb2R1bGVGYWN0b3J5KClcbntcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7XG5cdFx0Ly8gYWx0ZXJuYXRpdmUgbWV0aG9kLCBzaW1pbGFyIHRvIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuXHRcdC8vIGJ1dCB3aXRob3V0IHVzaW5nIGBldmFsYCAod2hpY2ggaXMgZGlzYWJsZWQgd2hlblxuXHRcdC8vIHVzaW5nIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cblxuXHRcdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuXHRcdGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG5cblx0XHQvLyBXaGVuIHJ1bm5pbmcgdGVzdHMgbm9uZSBvZiB0aGUgYWJvdmUgaGF2ZSBiZWVuIGRlZmluZWRcblx0XHRyZXR1cm4ge307XG5cdH0pKCk7XG5cblxuXHRmdW5jdGlvbiBnZXRXb3JrZXJCbG9iKCkge1xuXHRcdHZhciBVUkwgPSBnbG9iYWwuVVJMIHx8IGdsb2JhbC53ZWJraXRVUkwgfHwgbnVsbDtcblx0XHR2YXIgY29kZSA9IG1vZHVsZUZhY3RvcnkudG9TdHJpbmcoKTtcblx0XHRyZXR1cm4gUGFwYS5CTE9CX1VSTCB8fCAoUGFwYS5CTE9CX1VSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW1widmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHsgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfSByZXR1cm4ge307IH0pKCk7IGdsb2JhbC5JU19QQVBBX1dPUktFUj10cnVlOyBcIiwgJygnLCBjb2RlLCAnKSgpOyddLCB7dHlwZTogJ3RleHQvamF2YXNjcmlwdCd9KSkpO1xuXHR9XG5cblx0dmFyIElTX1dPUktFUiA9ICFnbG9iYWwuZG9jdW1lbnQgJiYgISFnbG9iYWwucG9zdE1lc3NhZ2UsXG5cdFx0SVNfUEFQQV9XT1JLRVIgPSBnbG9iYWwuSVNfUEFQQV9XT1JLRVIgfHwgZmFsc2U7XG5cblx0dmFyIHdvcmtlcnMgPSB7fSwgd29ya2VySWRDb3VudGVyID0gMDtcblxuXHR2YXIgUGFwYSA9IHt9O1xuXG5cdFBhcGEucGFyc2UgPSBDc3ZUb0pzb247XG5cdFBhcGEudW5wYXJzZSA9IEpzb25Ub0NzdjtcblxuXHRQYXBhLlJFQ09SRF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTtcblx0UGFwYS5VTklUX1NFUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzEpO1xuXHRQYXBhLkJZVEVfT1JERVJfTUFSSyA9ICdcXHVmZWZmJztcblx0UGFwYS5CQURfREVMSU1JVEVSUyA9IFsnXFxyJywgJ1xcbicsICdcIicsIFBhcGEuQllURV9PUkRFUl9NQVJLXTtcblx0UGFwYS5XT1JLRVJTX1NVUFBPUlRFRCA9ICFJU19XT1JLRVIgJiYgISFnbG9iYWwuV29ya2VyO1xuXHRQYXBhLk5PREVfU1RSRUFNX0lOUFVUID0gMTtcblxuXHQvLyBDb25maWd1cmFibGUgY2h1bmsgc2l6ZXMgZm9yIGxvY2FsIGFuZCByZW1vdGUgZmlsZXMsIHJlc3BlY3RpdmVseVxuXHRQYXBhLkxvY2FsQ2h1bmtTaXplID0gMTAyNCAqIDEwMjQgKiAxMDtcdC8vIDEwIE1CXG5cdFBhcGEuUmVtb3RlQ2h1bmtTaXplID0gMTAyNCAqIDEwMjQgKiA1O1x0Ly8gNSBNQlxuXHRQYXBhLkRlZmF1bHREZWxpbWl0ZXIgPSAnLCc7XHRcdFx0Ly8gVXNlZCBpZiBub3Qgc3BlY2lmaWVkIGFuZCBkZXRlY3Rpb24gZmFpbHNcblxuXHQvLyBFeHBvc2VkIGZvciB0ZXN0aW5nIGFuZCBkZXZlbG9wbWVudCBvbmx5XG5cdFBhcGEuUGFyc2VyID0gUGFyc2VyO1xuXHRQYXBhLlBhcnNlckhhbmRsZSA9IFBhcnNlckhhbmRsZTtcblx0UGFwYS5OZXR3b3JrU3RyZWFtZXIgPSBOZXR3b3JrU3RyZWFtZXI7XG5cdFBhcGEuRmlsZVN0cmVhbWVyID0gRmlsZVN0cmVhbWVyO1xuXHRQYXBhLlN0cmluZ1N0cmVhbWVyID0gU3RyaW5nU3RyZWFtZXI7XG5cdFBhcGEuUmVhZGFibGVTdHJlYW1TdHJlYW1lciA9IFJlYWRhYmxlU3RyZWFtU3RyZWFtZXI7XG5cdGlmICh0eXBlb2YgUEFQQV9CUk9XU0VSX0NPTlRFWFQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0UGFwYS5EdXBsZXhTdHJlYW1TdHJlYW1lciA9IER1cGxleFN0cmVhbVN0cmVhbWVyO1xuXHR9XG5cblx0aWYgKGdsb2JhbC5qUXVlcnkpXG5cdHtcblx0XHR2YXIgJCA9IGdsb2JhbC5qUXVlcnk7XG5cdFx0JC5mbi5wYXJzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbmZpZyA9IG9wdGlvbnMuY29uZmlnIHx8IHt9O1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbihpZHgpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBzdXBwb3J0ZWQgPSAkKHRoaXMpLnByb3AoJ3RhZ05hbWUnKS50b1VwcGVyQ2FzZSgpID09PSAnSU5QVVQnXG5cdFx0XHRcdFx0XHRcdFx0JiYgJCh0aGlzKS5hdHRyKCd0eXBlJykudG9Mb3dlckNhc2UoKSA9PT0gJ2ZpbGUnXG5cdFx0XHRcdFx0XHRcdFx0JiYgZ2xvYmFsLkZpbGVSZWFkZXI7XG5cblx0XHRcdFx0aWYgKCFzdXBwb3J0ZWQgfHwgIXRoaXMuZmlsZXMgfHwgdGhpcy5maWxlcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHQvLyBjb250aW51ZSB0byBuZXh0IGlucHV0IGVsZW1lbnRcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcblx0XHRcdFx0XHRcdGZpbGU6IHRoaXMuZmlsZXNbaV0sXG5cdFx0XHRcdFx0XHRpbnB1dEVsZW06IHRoaXMsXG5cdFx0XHRcdFx0XHRpbnN0YW5jZUNvbmZpZzogJC5leHRlbmQoe30sIGNvbmZpZylcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHBhcnNlTmV4dEZpbGUoKTtcdC8vIGJlZ2luIHBhcnNpbmdcblx0XHRcdHJldHVybiB0aGlzO1x0XHQvLyBtYWludGFpbnMgY2hhaW5hYmlsaXR5XG5cblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VOZXh0RmlsZSgpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChxdWV1ZS5sZW5ndGggPT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNvbXBsZXRlKSlcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZiA9IHF1ZXVlWzBdO1xuXG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuYmVmb3JlKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IG9wdGlvbnMuYmVmb3JlKGYuZmlsZSwgZi5pbnB1dEVsZW0pO1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiByZXR1cm5lZCA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHJldHVybmVkLmFjdGlvbiA9PT0gJ2Fib3J0Jylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZXJyb3IoJ0Fib3J0RXJyb3InLCBmLmZpbGUsIGYuaW5wdXRFbGVtLCByZXR1cm5lZC5yZWFzb24pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHQvLyBBYm9ydHMgYWxsIHF1ZXVlZCBmaWxlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocmV0dXJuZWQuYWN0aW9uID09PSAnc2tpcCcpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZpbGVDb21wbGV0ZSgpO1x0Ly8gcGFyc2UgdGhlIG5leHQgZmlsZSBpbiB0aGUgcXVldWUsIGlmIGFueVxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgcmV0dXJuZWQuY29uZmlnID09PSAnb2JqZWN0Jylcblx0XHRcdFx0XHRcdFx0Zi5pbnN0YW5jZUNvbmZpZyA9ICQuZXh0ZW5kKGYuaW5zdGFuY2VDb25maWcsIHJldHVybmVkLmNvbmZpZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHJldHVybmVkID09PSAnc2tpcCcpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZmlsZUNvbXBsZXRlKCk7XHQvLyBwYXJzZSB0aGUgbmV4dCBmaWxlIGluIHRoZSBxdWV1ZSwgaWYgYW55XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV3JhcCB1cCB0aGUgdXNlcidzIGNvbXBsZXRlIGNhbGxiYWNrLCBpZiBhbnksIHNvIHRoYXQgb3VycyBhbHNvIGdldHMgZXhlY3V0ZWRcblx0XHRcdFx0dmFyIHVzZXJDb21wbGV0ZUZ1bmMgPSBmLmluc3RhbmNlQ29uZmlnLmNvbXBsZXRlO1xuXHRcdFx0XHRmLmluc3RhbmNlQ29uZmlnLmNvbXBsZXRlID0gZnVuY3Rpb24ocmVzdWx0cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChpc0Z1bmN0aW9uKHVzZXJDb21wbGV0ZUZ1bmMpKVxuXHRcdFx0XHRcdFx0dXNlckNvbXBsZXRlRnVuYyhyZXN1bHRzLCBmLmZpbGUsIGYuaW5wdXRFbGVtKTtcblx0XHRcdFx0XHRmaWxlQ29tcGxldGUoKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRQYXBhLnBhcnNlKGYuZmlsZSwgZi5pbnN0YW5jZUNvbmZpZyk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGVycm9yKG5hbWUsIGZpbGUsIGVsZW0sIHJlYXNvbilcblx0XHRcdHtcblx0XHRcdFx0aWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5lcnJvcikpXG5cdFx0XHRcdFx0b3B0aW9ucy5lcnJvcih7bmFtZTogbmFtZX0sIGZpbGUsIGVsZW0sIHJlYXNvbik7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGZpbGVDb21wbGV0ZSgpXG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXVlLnNwbGljZSgwLCAxKTtcblx0XHRcdFx0cGFyc2VOZXh0RmlsZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXG5cdGlmIChJU19QQVBBX1dPUktFUilcblx0e1xuXHRcdGdsb2JhbC5vbm1lc3NhZ2UgPSB3b3JrZXJUaHJlYWRSZWNlaXZlZE1lc3NhZ2U7XG5cdH1cblxuXG5cblxuXHRmdW5jdGlvbiBDc3ZUb0pzb24oX2lucHV0LCBfY29uZmlnKVxuXHR7XG5cdFx0X2NvbmZpZyA9IF9jb25maWcgfHwge307XG5cdFx0dmFyIGR5bmFtaWNUeXBpbmcgPSBfY29uZmlnLmR5bmFtaWNUeXBpbmcgfHwgZmFsc2U7XG5cdFx0aWYgKGlzRnVuY3Rpb24oZHluYW1pY1R5cGluZykpIHtcblx0XHRcdF9jb25maWcuZHluYW1pY1R5cGluZ0Z1bmN0aW9uID0gZHluYW1pY1R5cGluZztcblx0XHRcdC8vIFdpbGwgYmUgZmlsbGVkIG9uIGZpcnN0IHJvdyBjYWxsXG5cdFx0XHRkeW5hbWljVHlwaW5nID0ge307XG5cdFx0fVxuXHRcdF9jb25maWcuZHluYW1pY1R5cGluZyA9IGR5bmFtaWNUeXBpbmc7XG5cblx0XHRfY29uZmlnLnRyYW5zZm9ybSA9IGlzRnVuY3Rpb24oX2NvbmZpZy50cmFuc2Zvcm0pID8gX2NvbmZpZy50cmFuc2Zvcm0gOiBmYWxzZTtcblxuXHRcdGlmIChfY29uZmlnLndvcmtlciAmJiBQYXBhLldPUktFUlNfU1VQUE9SVEVEKVxuXHRcdHtcblx0XHRcdHZhciB3ID0gbmV3V29ya2VyKCk7XG5cblx0XHRcdHcudXNlclN0ZXAgPSBfY29uZmlnLnN0ZXA7XG5cdFx0XHR3LnVzZXJDaHVuayA9IF9jb25maWcuY2h1bms7XG5cdFx0XHR3LnVzZXJDb21wbGV0ZSA9IF9jb25maWcuY29tcGxldGU7XG5cdFx0XHR3LnVzZXJFcnJvciA9IF9jb25maWcuZXJyb3I7XG5cblx0XHRcdF9jb25maWcuc3RlcCA9IGlzRnVuY3Rpb24oX2NvbmZpZy5zdGVwKTtcblx0XHRcdF9jb25maWcuY2h1bmsgPSBpc0Z1bmN0aW9uKF9jb25maWcuY2h1bmspO1xuXHRcdFx0X2NvbmZpZy5jb21wbGV0ZSA9IGlzRnVuY3Rpb24oX2NvbmZpZy5jb21wbGV0ZSk7XG5cdFx0XHRfY29uZmlnLmVycm9yID0gaXNGdW5jdGlvbihfY29uZmlnLmVycm9yKTtcblx0XHRcdGRlbGV0ZSBfY29uZmlnLndvcmtlcjtcdC8vIHByZXZlbnQgaW5maW5pdGUgbG9vcFxuXG5cdFx0XHR3LnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0aW5wdXQ6IF9pbnB1dCxcblx0XHRcdFx0Y29uZmlnOiBfY29uZmlnLFxuXHRcdFx0XHR3b3JrZXJJZDogdy5pZFxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc3RyZWFtZXIgPSBudWxsO1xuXHRcdGlmIChfaW5wdXQgPT09IFBhcGEuTk9ERV9TVFJFQU1fSU5QVVQgJiYgdHlwZW9mIFBBUEFfQlJPV1NFUl9DT05URVhUID09PSAndW5kZWZpbmVkJylcblx0XHR7XG5cdFx0XHQvLyBjcmVhdGUgYSBub2RlIER1cGxleCBzdHJlYW0gZm9yIHVzZVxuXHRcdFx0Ly8gd2l0aCAucGlwZVxuXHRcdFx0c3RyZWFtZXIgPSBuZXcgRHVwbGV4U3RyZWFtU3RyZWFtZXIoX2NvbmZpZyk7XG5cdFx0XHRyZXR1cm4gc3RyZWFtZXIuZ2V0U3RyZWFtKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBfaW5wdXQgPT09ICdzdHJpbmcnKVxuXHRcdHtcblx0XHRcdF9pbnB1dCA9IHN0cmlwQm9tKF9pbnB1dCk7XG5cdFx0XHRpZiAoX2NvbmZpZy5kb3dubG9hZClcblx0XHRcdFx0c3RyZWFtZXIgPSBuZXcgTmV0d29ya1N0cmVhbWVyKF9jb25maWcpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzdHJlYW1lciA9IG5ldyBTdHJpbmdTdHJlYW1lcihfY29uZmlnKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoX2lucHV0LnJlYWRhYmxlID09PSB0cnVlICYmIGlzRnVuY3Rpb24oX2lucHV0LnJlYWQpICYmIGlzRnVuY3Rpb24oX2lucHV0Lm9uKSlcblx0XHR7XG5cdFx0XHRzdHJlYW1lciA9IG5ldyBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyKF9jb25maWcpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoZ2xvYmFsLkZpbGUgJiYgX2lucHV0IGluc3RhbmNlb2YgRmlsZSkgfHwgX2lucHV0IGluc3RhbmNlb2YgT2JqZWN0KVx0Ly8gLi4uU2FmYXJpLiAoc2VlIGlzc3VlICMxMDYpXG5cdFx0XHRzdHJlYW1lciA9IG5ldyBGaWxlU3RyZWFtZXIoX2NvbmZpZyk7XG5cblx0XHRyZXR1cm4gc3RyZWFtZXIuc3RyZWFtKF9pbnB1dCk7XG5cblx0XHQvLyBTdHJpcCBjaGFyYWN0ZXIgZnJvbSBVVEYtOCBCT00gZW5jb2RlZCBmaWxlcyB0aGF0IGNhdXNlIGlzc3VlIHBhcnNpbmcgdGhlIGZpbGVcblx0XHRmdW5jdGlvbiBzdHJpcEJvbShzdHJpbmcpIHtcblx0XHRcdGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gMHhmZWZmKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpbmcuc2xpY2UoMSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdH1cblx0fVxuXG5cblxuXG5cblxuXHRmdW5jdGlvbiBKc29uVG9Dc3YoX2lucHV0LCBfY29uZmlnKVxuXHR7XG5cdFx0Ly8gRGVmYXVsdCBjb25maWd1cmF0aW9uXG5cblx0XHQvKiogd2hldGhlciB0byBzdXJyb3VuZCBldmVyeSBkYXR1bSB3aXRoIHF1b3RlcyAqL1xuXHRcdHZhciBfcXVvdGVzID0gZmFsc2U7XG5cblx0XHQvKiogd2hldGhlciB0byB3cml0ZSBoZWFkZXJzICovXG5cdFx0dmFyIF93cml0ZUhlYWRlciA9IHRydWU7XG5cblx0XHQvKiogZGVsaW1pdGluZyBjaGFyYWN0ZXIocykgKi9cblx0XHR2YXIgX2RlbGltaXRlciA9ICcsJztcblxuXHRcdC8qKiBuZXdsaW5lIGNoYXJhY3RlcihzKSAqL1xuXHRcdHZhciBfbmV3bGluZSA9ICdcXHJcXG4nO1xuXG5cdFx0LyoqIHF1b3RlIGNoYXJhY3RlciAqL1xuXHRcdHZhciBfcXVvdGVDaGFyID0gJ1wiJztcblxuXHRcdC8qKiBlc2NhcGVkIHF1b3RlIGNoYXJhY3RlciwgZWl0aGVyIFwiXCIgb3IgPGNvbmZpZy5lc2NhcGVDaGFyPlwiICovXG5cdFx0dmFyIF9lc2NhcGVkUXVvdGUgPSBfcXVvdGVDaGFyICsgX3F1b3RlQ2hhcjtcblxuXHRcdC8qKiB3aGV0aGVyIHRvIHNraXAgZW1wdHkgbGluZXMgKi9cblx0XHR2YXIgX3NraXBFbXB0eUxpbmVzID0gZmFsc2U7XG5cblx0XHQvKiogdGhlIGNvbHVtbnMgKGtleXMpIHdlIGV4cGVjdCB3aGVuIHdlIHVucGFyc2Ugb2JqZWN0cyAqL1xuXHRcdHZhciBfY29sdW1ucyA9IG51bGw7XG5cblx0XHQvKiogd2hldGhlciB0byBwcmV2ZW50IG91dHB1dHRpbmcgY2VsbHMgdGhhdCBjYW4gYmUgcGFyc2VkIGFzIGZvcm11bGFlIGJ5IHNwcmVhZHNoZWV0IHNvZnR3YXJlIChFeGNlbCBhbmQgTGlicmVPZmZpY2UpICovXG5cdFx0dmFyIF9lc2NhcGVGb3JtdWxhZSA9IGZhbHNlO1xuXG5cdFx0dW5wYWNrQ29uZmlnKCk7XG5cblx0XHR2YXIgcXVvdGVDaGFyUmVnZXggPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChfcXVvdGVDaGFyKSwgJ2cnKTtcblxuXHRcdGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJylcblx0XHRcdF9pbnB1dCA9IEpTT04ucGFyc2UoX2lucHV0KTtcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KF9pbnB1dCkpXG5cdFx0e1xuXHRcdFx0aWYgKCFfaW5wdXQubGVuZ3RoIHx8IEFycmF5LmlzQXJyYXkoX2lucHV0WzBdKSlcblx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShudWxsLCBfaW5wdXQsIF9za2lwRW1wdHlMaW5lcyk7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0WzBdID09PSAnb2JqZWN0Jylcblx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShfY29sdW1ucyB8fCBPYmplY3Qua2V5cyhfaW5wdXRbMF0pLCBfaW5wdXQsIF9za2lwRW1wdHlMaW5lcyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBfaW5wdXQgPT09ICdvYmplY3QnKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgX2lucHV0LmRhdGEgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfaW5wdXQuZGF0YSA9IEpTT04ucGFyc2UoX2lucHV0LmRhdGEpO1xuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShfaW5wdXQuZGF0YSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghX2lucHV0LmZpZWxkcylcblx0XHRcdFx0XHRfaW5wdXQuZmllbGRzID0gX2lucHV0Lm1ldGEgJiYgX2lucHV0Lm1ldGEuZmllbGRzIHx8IF9jb2x1bW5zO1xuXG5cdFx0XHRcdGlmICghX2lucHV0LmZpZWxkcylcblx0XHRcdFx0XHRfaW5wdXQuZmllbGRzID0gIEFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGFbMF0pXG5cdFx0XHRcdFx0XHQ/IF9pbnB1dC5maWVsZHNcblx0XHRcdFx0XHRcdDogdHlwZW9mIF9pbnB1dC5kYXRhWzBdID09PSAnb2JqZWN0J1xuXHRcdFx0XHRcdFx0XHQ/IE9iamVjdC5rZXlzKF9pbnB1dC5kYXRhWzBdKVxuXHRcdFx0XHRcdFx0XHQ6IFtdO1xuXG5cdFx0XHRcdGlmICghKEFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGFbMF0pKSAmJiB0eXBlb2YgX2lucHV0LmRhdGFbMF0gIT09ICdvYmplY3QnKVxuXHRcdFx0XHRcdF9pbnB1dC5kYXRhID0gW19pbnB1dC5kYXRhXTtcdC8vIGhhbmRsZXMgaW5wdXQgbGlrZSBbMSwyLDNdIG9yIFsnYXNkZiddXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXJpYWxpemUoX2lucHV0LmZpZWxkcyB8fCBbXSwgX2lucHV0LmRhdGEgfHwgW10sIF9za2lwRW1wdHlMaW5lcyk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCAoYW55IHZhbGlkIHBhdGhzIHNob3VsZCByZXR1cm4gYmVmb3JlIHRoaXMpXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2VyaWFsaXplIHVucmVjb2duaXplZCBpbnB1dCcpO1xuXG5cblx0XHRmdW5jdGlvbiB1bnBhY2tDb25maWcoKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZyAhPT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLmRlbGltaXRlciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAmJiAhUGFwYS5CQURfREVMSU1JVEVSUy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIF9jb25maWcuZGVsaW1pdGVyLmluZGV4T2YodmFsdWUpICE9PSAtMTsgfSkubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRfZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5xdW90ZXMgPT09ICdib29sZWFuJ1xuXHRcdFx0XHR8fCB0eXBlb2YgX2NvbmZpZy5xdW90ZXMgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShfY29uZmlnLnF1b3RlcykpXG5cdFx0XHRcdF9xdW90ZXMgPSBfY29uZmlnLnF1b3RlcztcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnYm9vbGVhbidcblx0XHRcdFx0fHwgdHlwZW9mIF9jb25maWcuc2tpcEVtcHR5TGluZXMgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfc2tpcEVtcHR5TGluZXMgPSBfY29uZmlnLnNraXBFbXB0eUxpbmVzO1xuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcubmV3bGluZSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdF9uZXdsaW5lID0gX2NvbmZpZy5uZXdsaW5lO1xuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcucXVvdGVDaGFyID09PSAnc3RyaW5nJylcblx0XHRcdFx0X3F1b3RlQ2hhciA9IF9jb25maWcucXVvdGVDaGFyO1xuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcuaGVhZGVyID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdF93cml0ZUhlYWRlciA9IF9jb25maWcuaGVhZGVyO1xuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShfY29uZmlnLmNvbHVtbnMpKSB7XG5cblx0XHRcdFx0aWYgKF9jb25maWcuY29sdW1ucy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGNvbHVtbnMgaXMgZW1wdHknKTtcblxuXHRcdFx0XHRfY29sdW1ucyA9IF9jb25maWcuY29sdW1ucztcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9jb25maWcuZXNjYXBlQ2hhciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdF9lc2NhcGVkUXVvdGUgPSBfY29uZmlnLmVzY2FwZUNoYXIgKyBfcXVvdGVDaGFyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2NvbmZpZy5lc2NhcGVGb3JtdWxhZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRfZXNjYXBlRm9ybXVsYWUgPSBfY29uZmlnLmVzY2FwZUZvcm11bGFlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgX2NvbmZpZy5lc2NhcGVGb3JtdWxhZSA9PT0gJ2Jvb2xlYW4nICYmIF9jb25maWcuZXNjYXBlRm9ybXVsYWUpIHtcblx0XHRcdFx0X2VzY2FwZUZvcm11bGFlID0gIC9eWz0rXFwtQFxcdFxccl0uKiQvO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKiBUaGUgZG91YmxlIGZvciBsb29wIHRoYXQgaXRlcmF0ZXMgdGhlIGRhdGEgYW5kIHdyaXRlcyBvdXQgYSBDU1Ygc3RyaW5nIGluY2x1ZGluZyBoZWFkZXIgcm93ICovXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcywgZGF0YSwgc2tpcEVtcHR5TGluZXMpXG5cdFx0e1xuXHRcdFx0dmFyIGNzdiA9ICcnO1xuXG5cdFx0XHRpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGZpZWxkcyA9IEpTT04ucGFyc2UoZmllbGRzKTtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG5cdFx0XHR2YXIgaGFzSGVhZGVyID0gQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIGZpZWxkcy5sZW5ndGggPiAwO1xuXHRcdFx0dmFyIGRhdGFLZXllZEJ5RmllbGQgPSAhKEFycmF5LmlzQXJyYXkoZGF0YVswXSkpO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhIGhlYWRlciByb3csIHdyaXRlIGl0IGZpcnN0XG5cdFx0XHRpZiAoaGFzSGVhZGVyICYmIF93cml0ZUhlYWRlcilcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaSA+IDApXG5cdFx0XHRcdFx0XHRjc3YgKz0gX2RlbGltaXRlcjtcblx0XHRcdFx0XHRjc3YgKz0gc2FmZShmaWVsZHNbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkYXRhLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0Y3N2ICs9IF9uZXdsaW5lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVuIHdyaXRlIG91dCB0aGUgZGF0YVxuXHRcdFx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgZGF0YS5sZW5ndGg7IHJvdysrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbWF4Q29sID0gaGFzSGVhZGVyID8gZmllbGRzLmxlbmd0aCA6IGRhdGFbcm93XS5sZW5ndGg7XG5cblx0XHRcdFx0dmFyIGVtcHR5TGluZSA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgbnVsbExpbmUgPSBoYXNIZWFkZXIgPyBPYmplY3Qua2V5cyhkYXRhW3Jvd10pLmxlbmd0aCA9PT0gMCA6IGRhdGFbcm93XS5sZW5ndGggPT09IDA7XG5cdFx0XHRcdGlmIChza2lwRW1wdHlMaW5lcyAmJiAhaGFzSGVhZGVyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW1wdHlMaW5lID0gc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknID8gZGF0YVtyb3ddLmpvaW4oJycpLnRyaW0oKSA9PT0gJycgOiBkYXRhW3Jvd10ubGVuZ3RoID09PSAxICYmIGRhdGFbcm93XVswXS5sZW5ndGggPT09IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5JyAmJiBoYXNIZWFkZXIpIHtcblx0XHRcdFx0XHR2YXIgbGluZSA9IFtdO1xuXHRcdFx0XHRcdGZvciAodmFyIGMgPSAwOyBjIDwgbWF4Q29sOyBjKyspIHtcblx0XHRcdFx0XHRcdHZhciBjeCA9IGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY10gOiBjO1xuXHRcdFx0XHRcdFx0bGluZS5wdXNoKGRhdGFbcm93XVtjeF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbXB0eUxpbmUgPSBsaW5lLmpvaW4oJycpLnRyaW0oKSA9PT0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFlbXB0eUxpbmUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtYXhDb2w7IGNvbCsrKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChjb2wgPiAwICYmICFudWxsTGluZSlcblx0XHRcdFx0XHRcdFx0Y3N2ICs9IF9kZWxpbWl0ZXI7XG5cdFx0XHRcdFx0XHR2YXIgY29sSWR4ID0gaGFzSGVhZGVyICYmIGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY29sXSA6IGNvbDtcblx0XHRcdFx0XHRcdGNzdiArPSBzYWZlKGRhdGFbcm93XVtjb2xJZHhdLCBjb2wpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocm93IDwgZGF0YS5sZW5ndGggLSAxICYmICghc2tpcEVtcHR5TGluZXMgfHwgKG1heENvbCA+IDAgJiYgIW51bGxMaW5lKSkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y3N2ICs9IF9uZXdsaW5lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNzdjtcblx0XHR9XG5cblx0XHQvKiogRW5jbG9zZXMgYSB2YWx1ZSBhcm91bmQgcXVvdGVzIGlmIG5lZWRlZCAobWFrZXMgYSB2YWx1ZSBzYWZlIGZvciBDU1YgaW5zZXJ0aW9uKSAqL1xuXHRcdGZ1bmN0aW9uIHNhZmUoc3RyLCBjb2wpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnIHx8IHN0ciA9PT0gbnVsbClcblx0XHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0XHRpZiAoc3RyLmNvbnN0cnVjdG9yID09PSBEYXRlKVxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKS5zbGljZSgxLCAyNSk7XG5cblx0XHRcdHZhciBuZWVkc1F1b3RlcyA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoX2VzY2FwZUZvcm11bGFlICYmIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgX2VzY2FwZUZvcm11bGFlLnRlc3Qoc3RyKSkge1xuXHRcdFx0XHRzdHIgPSBcIidcIiArIHN0cjtcblx0XHRcdFx0bmVlZHNRdW90ZXMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXNjYXBlZFF1b3RlU3RyID0gc3RyLnRvU3RyaW5nKCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgX2VzY2FwZWRRdW90ZSk7XG5cblx0XHRcdG5lZWRzUXVvdGVzID0gbmVlZHNRdW90ZXNcblx0XHRcdFx0XHRcdFx0fHwgX3F1b3RlcyA9PT0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHR8fCAodHlwZW9mIF9xdW90ZXMgPT09ICdmdW5jdGlvbicgJiYgX3F1b3RlcyhzdHIsIGNvbCkpXG5cdFx0XHRcdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KF9xdW90ZXMpICYmIF9xdW90ZXNbY29sXSlcblx0XHRcdFx0XHRcdFx0fHwgaGFzQW55KGVzY2FwZWRRdW90ZVN0ciwgUGFwYS5CQURfREVMSU1JVEVSUylcblx0XHRcdFx0XHRcdFx0fHwgZXNjYXBlZFF1b3RlU3RyLmluZGV4T2YoX2RlbGltaXRlcikgPiAtMVxuXHRcdFx0XHRcdFx0XHR8fCBlc2NhcGVkUXVvdGVTdHIuY2hhckF0KDApID09PSAnICdcblx0XHRcdFx0XHRcdFx0fHwgZXNjYXBlZFF1b3RlU3RyLmNoYXJBdChlc2NhcGVkUXVvdGVTdHIubGVuZ3RoIC0gMSkgPT09ICcgJztcblxuXHRcdFx0cmV0dXJuIG5lZWRzUXVvdGVzID8gX3F1b3RlQ2hhciArIGVzY2FwZWRRdW90ZVN0ciArIF9xdW90ZUNoYXIgOiBlc2NhcGVkUXVvdGVTdHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFzQW55KHN0ciwgc3Vic3RyaW5ncylcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGlmIChzdHIuaW5kZXhPZihzdWJzdHJpbmdzW2ldKSA+IC0xKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqIENodW5rU3RyZWFtZXIgaXMgdGhlIGJhc2UgcHJvdG90eXBlIGZvciB2YXJpb3VzIHN0cmVhbWVyIGltcGxlbWVudGF0aW9ucy4gKi9cblx0ZnVuY3Rpb24gQ2h1bmtTdHJlYW1lcihjb25maWcpXG5cdHtcblx0XHR0aGlzLl9oYW5kbGUgPSBudWxsO1xuXHRcdHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG5cdFx0dGhpcy5fY29tcGxldGVkID0gZmFsc2U7XG5cdFx0dGhpcy5faGFsdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5faW5wdXQgPSBudWxsO1xuXHRcdHRoaXMuX2Jhc2VJbmRleCA9IDA7XG5cdFx0dGhpcy5fcGFydGlhbExpbmUgPSAnJztcblx0XHR0aGlzLl9yb3dDb3VudCA9IDA7XG5cdFx0dGhpcy5fc3RhcnQgPSAwO1xuXHRcdHRoaXMuX25leHRDaHVuayA9IG51bGw7XG5cdFx0dGhpcy5pc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuXHRcdHRoaXMuX2NvbXBsZXRlUmVzdWx0cyA9IHtcblx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdG1ldGE6IHt9XG5cdFx0fTtcblx0XHRyZXBsYWNlQ29uZmlnLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHRoaXMucGFyc2VDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBpc0Zha2VDaHVuaylcblx0XHR7XG5cdFx0XHQvLyBGaXJzdCBjaHVuayBwcmUtcHJvY2Vzc2luZ1xuXHRcdFx0Y29uc3Qgc2tpcEZpcnN0TkxpbmVzID0gcGFyc2VJbnQodGhpcy5fY29uZmlnLnNraXBGaXJzdE5MaW5lcykgfHwgMDtcblx0XHRcdGlmICh0aGlzLmlzRmlyc3RDaHVuayAmJiBza2lwRmlyc3ROTGluZXMgPiAwKSB7XG5cdFx0XHRcdGxldCBfbmV3bGluZSA9IHRoaXMuX2NvbmZpZy5uZXdsaW5lO1xuXHRcdFx0XHRpZiAoIV9uZXdsaW5lKSB7XG5cdFx0XHRcdFx0Y29uc3QgcXVvdGVDaGFyID0gdGhpcy5fY29uZmlnLnF1b3RlQ2hhciB8fCAnXCInO1xuXHRcdFx0XHRcdF9uZXdsaW5lID0gdGhpcy5faGFuZGxlLmd1ZXNzTGluZUVuZGluZ3MoY2h1bmssIHF1b3RlQ2hhcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3Qgc3BsaXRDaHVuayA9IGNodW5rLnNwbGl0KF9uZXdsaW5lKTtcblx0XHRcdFx0Y2h1bmsgPSBbLi4uc3BsaXRDaHVuay5zbGljZShza2lwRmlyc3ROTGluZXMpXS5qb2luKF9uZXdsaW5lKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIG1vZGlmaWVkQ2h1bmsgPSB0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuayhjaHVuayk7XG5cdFx0XHRcdGlmIChtb2RpZmllZENodW5rICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0Y2h1bmsgPSBtb2RpZmllZENodW5rO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2hhbHRlZCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBSZWpvaW4gdGhlIGxpbmUgd2UgbGlrZWx5IGp1c3Qgc3BsaXQgaW4gdHdvIGJ5IGNodW5raW5nIHRoZSBmaWxlXG5cdFx0XHR2YXIgYWdncmVnYXRlID0gdGhpcy5fcGFydGlhbExpbmUgKyBjaHVuaztcblx0XHRcdHRoaXMuX3BhcnRpYWxMaW5lID0gJyc7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IHRoaXMuX2hhbmRsZS5wYXJzZShhZ2dyZWdhdGUsIHRoaXMuX2Jhc2VJbmRleCwgIXRoaXMuX2ZpbmlzaGVkKTtcblxuXHRcdFx0aWYgKHRoaXMuX2hhbmRsZS5wYXVzZWQoKSB8fCB0aGlzLl9oYW5kbGUuYWJvcnRlZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2hhbHRlZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxhc3RJbmRleCA9IHJlc3VsdHMubWV0YS5jdXJzb3I7XG5cblx0XHRcdGlmICghdGhpcy5fZmluaXNoZWQpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3BhcnRpYWxMaW5lID0gYWdncmVnYXRlLnN1YnN0cmluZyhsYXN0SW5kZXggLSB0aGlzLl9iYXNlSW5kZXgpO1xuXHRcdFx0XHR0aGlzLl9iYXNlSW5kZXggPSBsYXN0SW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZXN1bHRzICYmIHJlc3VsdHMuZGF0YSlcblx0XHRcdFx0dGhpcy5fcm93Q291bnQgKz0gcmVzdWx0cy5kYXRhLmxlbmd0aDtcblxuXHRcdFx0dmFyIGZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyA9IHRoaXMuX2ZpbmlzaGVkIHx8ICh0aGlzLl9jb25maWcucHJldmlldyAmJiB0aGlzLl9yb3dDb3VudCA+PSB0aGlzLl9jb25maWcucHJldmlldyk7XG5cblx0XHRcdGlmIChJU19QQVBBX1dPUktFUilcblx0XHRcdHtcblx0XHRcdFx0Z2xvYmFsLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0XHRyZXN1bHRzOiByZXN1bHRzLFxuXHRcdFx0XHRcdHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcblx0XHRcdFx0XHRmaW5pc2hlZDogZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9jb25maWcuY2h1bmspICYmICFpc0Zha2VDaHVuaylcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fY29uZmlnLmNodW5rKHJlc3VsdHMsIHRoaXMuX2hhbmRsZSk7XG5cdFx0XHRcdGlmICh0aGlzLl9oYW5kbGUucGF1c2VkKCkgfHwgdGhpcy5faGFuZGxlLmFib3J0ZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuX2hhbHRlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHRoaXMuX2NvbXBsZXRlUmVzdWx0cyA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9jb25maWcuc3RlcCAmJiAhdGhpcy5fY29uZmlnLmNodW5rKSB7XG5cdFx0XHRcdHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhID0gdGhpcy5fY29tcGxldGVSZXN1bHRzLmRhdGEuY29uY2F0KHJlc3VsdHMuZGF0YSk7XG5cdFx0XHRcdHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5lcnJvcnMgPSB0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzLmNvbmNhdChyZXN1bHRzLmVycm9ycyk7XG5cdFx0XHRcdHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5tZXRhID0gcmVzdWx0cy5tZXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2NvbXBsZXRlZCAmJiBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgJiYgaXNGdW5jdGlvbih0aGlzLl9jb25maWcuY29tcGxldGUpICYmICghcmVzdWx0cyB8fCAhcmVzdWx0cy5tZXRhLmFib3J0ZWQpKSB7XG5cdFx0XHRcdHRoaXMuX2NvbmZpZy5jb21wbGV0ZSh0aGlzLl9jb21wbGV0ZVJlc3VsdHMsIHRoaXMuX2lucHV0KTtcblx0XHRcdFx0dGhpcy5fY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgJiYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLm1ldGEucGF1c2VkKSlcblx0XHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHR0aGlzLl9zZW5kRXJyb3IgPSBmdW5jdGlvbihlcnJvcilcblx0XHR7XG5cdFx0XHRpZiAoaXNGdW5jdGlvbih0aGlzLl9jb25maWcuZXJyb3IpKVxuXHRcdFx0XHR0aGlzLl9jb25maWcuZXJyb3IoZXJyb3IpO1xuXHRcdFx0ZWxzZSBpZiAoSVNfUEFQQV9XT1JLRVIgJiYgdGhpcy5fY29uZmlnLmVycm9yKVxuXHRcdFx0e1xuXHRcdFx0XHRnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRcdHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcblx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0ZmluaXNoZWQ6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlQ29uZmlnKGNvbmZpZylcblx0XHR7XG5cdFx0XHQvLyBEZWVwLWNvcHkgdGhlIGNvbmZpZyBzbyB3ZSBjYW4gZWRpdCBpdFxuXHRcdFx0dmFyIGNvbmZpZ0NvcHkgPSBjb3B5KGNvbmZpZyk7XG5cdFx0XHRjb25maWdDb3B5LmNodW5rU2l6ZSA9IHBhcnNlSW50KGNvbmZpZ0NvcHkuY2h1bmtTaXplKTtcdC8vIHBhcnNlSW50IFZFUlkgaW1wb3J0YW50IHNvIHdlIGRvbid0IGNvbmNhdGVuYXRlIHN0cmluZ3MhXG5cdFx0XHRpZiAoIWNvbmZpZy5zdGVwICYmICFjb25maWcuY2h1bmspXG5cdFx0XHRcdGNvbmZpZ0NvcHkuY2h1bmtTaXplID0gbnVsbDsgIC8vIGRpc2FibGUgUmFuZ2UgaGVhZGVyIGlmIG5vdCBzdHJlYW1pbmc7IGJhZCB2YWx1ZXMgYnJlYWsgSUlTIC0gc2VlIGlzc3VlICMxOTZcblx0XHRcdHRoaXMuX2hhbmRsZSA9IG5ldyBQYXJzZXJIYW5kbGUoY29uZmlnQ29weSk7XG5cdFx0XHR0aGlzLl9oYW5kbGUuc3RyZWFtZXIgPSB0aGlzO1xuXHRcdFx0dGhpcy5fY29uZmlnID0gY29uZmlnQ29weTtcdC8vIHBlcnNpc3QgdGhlIGNvcHkgdG8gdGhlIGNhbGxlclxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gTmV0d29ya1N0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRpZiAoIWNvbmZpZy5jaHVua1NpemUpXG5cdFx0XHRjb25maWcuY2h1bmtTaXplID0gUGFwYS5SZW1vdGVDaHVua1NpemU7XG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR2YXIgeGhyO1xuXG5cdFx0aWYgKElTX1dPUktFUilcblx0XHR7XG5cdFx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3JlYWRDaHVuaygpO1xuXHRcdFx0XHR0aGlzLl9jaHVua0xvYWRlZCgpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fcmVhZENodW5rKCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMuc3RyZWFtID0gZnVuY3Rpb24odXJsKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lucHV0ID0gdXJsO1xuXHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XHQvLyBTdGFydHMgc3RyZWFtaW5nXG5cdFx0fTtcblxuXHRcdHRoaXMuX3JlYWRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fZmluaXNoZWQpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2NodW5rTG9hZGVkKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0eGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdGlmICh0aGlzLl9jb25maWcud2l0aENyZWRlbnRpYWxzKVxuXHRcdFx0e1xuXHRcdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy5fY29uZmlnLndpdGhDcmVkZW50aWFscztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFJU19XT1JLRVIpXG5cdFx0XHR7XG5cdFx0XHRcdHhoci5vbmxvYWQgPSBiaW5kRnVuY3Rpb24odGhpcy5fY2h1bmtMb2FkZWQsIHRoaXMpO1xuXHRcdFx0XHR4aHIub25lcnJvciA9IGJpbmRGdW5jdGlvbih0aGlzLl9jaHVua0Vycm9yLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0eGhyLm9wZW4odGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEJvZHkgPyAnUE9TVCcgOiAnR0VUJywgdGhpcy5faW5wdXQsICFJU19XT1JLRVIpO1xuXHRcdFx0Ly8gSGVhZGVycyBjYW4gb25seSBiZSBzZXQgd2hlbiBvbmNlIHRoZSByZXF1ZXN0IHN0YXRlIGlzIE9QRU5FRFxuXHRcdFx0aWYgKHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RIZWFkZXJzKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaGVhZGVycyA9IHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RIZWFkZXJzO1xuXG5cdFx0XHRcdGZvciAodmFyIGhlYWRlck5hbWUgaW4gaGVhZGVycylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlcnNbaGVhZGVyTmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9jb25maWcuY2h1bmtTaXplKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZW5kID0gdGhpcy5fc3RhcnQgKyB0aGlzLl9jb25maWcuY2h1bmtTaXplIC0gMTtcdC8vIG1pbnVzIG9uZSBiZWNhdXNlIGJ5dGUgcmFuZ2UgaXMgaW5jbHVzaXZlXG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgdGhpcy5fc3RhcnQgKyAnLScgKyBlbmQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR4aHIuc2VuZCh0aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0Qm9keSk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdHRoaXMuX2NodW5rRXJyb3IoZXJyLm1lc3NhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoSVNfV09SS0VSICYmIHhoci5zdGF0dXMgPT09IDApXG5cdFx0XHRcdHRoaXMuX2NodW5rRXJyb3IoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5fY2h1bmtMb2FkZWQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPj0gNDAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9jaHVua0Vycm9yKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGNodW5ja1NpemUgYXMgaXQgbWF5IGJlIGEgZGlmZXJlbmNlIG9uIHJlcG9uc2UgbGVudGdoIGR1ZSB0byBjaGFyYWN0ZXJzIHdpdGggbW9yZSB0aGFuIDEgYnl0ZVxuXHRcdFx0dGhpcy5fc3RhcnQgKz0gdGhpcy5fY29uZmlnLmNodW5rU2l6ZSA/IHRoaXMuX2NvbmZpZy5jaHVua1NpemUgOiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aDtcblx0XHRcdHRoaXMuX2ZpbmlzaGVkID0gIXRoaXMuX2NvbmZpZy5jaHVua1NpemUgfHwgdGhpcy5fc3RhcnQgPj0gZ2V0RmlsZVNpemUoeGhyKTtcblx0XHRcdHRoaXMucGFyc2VDaHVuayh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5fY2h1bmtFcnJvciA9IGZ1bmN0aW9uKGVycm9yTWVzc2FnZSlcblx0XHR7XG5cdFx0XHR2YXIgZXJyb3JUZXh0ID0geGhyLnN0YXR1c1RleHQgfHwgZXJyb3JNZXNzYWdlO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKG5ldyBFcnJvcihlcnJvclRleHQpKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RmlsZVNpemUoeGhyKVxuXHRcdHtcblx0XHRcdHZhciBjb250ZW50UmFuZ2UgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtUmFuZ2UnKTtcblx0XHRcdGlmIChjb250ZW50UmFuZ2UgPT09IG51bGwpIHsgLy8gbm8gY29udGVudCByYW5nZSwgdGhlbiBmaW5pc2ghXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZUludChjb250ZW50UmFuZ2Uuc3Vic3RyaW5nKGNvbnRlbnRSYW5nZS5sYXN0SW5kZXhPZignLycpICsgMSkpO1xuXHRcdH1cblx0fVxuXHROZXR3b3JrU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaHVua1N0cmVhbWVyLnByb3RvdHlwZSk7XG5cdE5ldHdvcmtTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXR3b3JrU3RyZWFtZXI7XG5cblxuXHRmdW5jdGlvbiBGaWxlU3RyZWFtZXIoY29uZmlnKVxuXHR7XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXHRcdGlmICghY29uZmlnLmNodW5rU2l6ZSlcblx0XHRcdGNvbmZpZy5jaHVua1NpemUgPSBQYXBhLkxvY2FsQ2h1bmtTaXplO1xuXHRcdENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdFx0dmFyIHJlYWRlciwgc2xpY2U7XG5cblx0XHQvLyBGaWxlUmVhZGVyIGlzIGJldHRlciB0aGFuIEZpbGVSZWFkZXJTeW5jIChldmVuIGluIHdvcmtlcikgLSBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjQ3MDg2NDkvMTA0ODg2MlxuXHRcdC8vIEJ1dCBGaXJlZm94IGlzIGEgcGlsbCwgdG9vIC0gc2VlIGlzc3VlICM3NjogaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZS9pc3N1ZXMvNzZcblx0XHR2YXIgdXNpbmdBc3luY1JlYWRlciA9IHR5cGVvZiBGaWxlUmVhZGVyICE9PSAndW5kZWZpbmVkJztcdC8vIFNhZmFyaSBkb2Vzbid0IGNvbnNpZGVyIGl0IGEgZnVuY3Rpb24gLSBzZWUgaXNzdWUgIzEwNVxuXG5cdFx0dGhpcy5zdHJlYW0gPSBmdW5jdGlvbihmaWxlKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lucHV0ID0gZmlsZTtcblx0XHRcdHNsaWNlID0gZmlsZS5zbGljZSB8fCBmaWxlLndlYmtpdFNsaWNlIHx8IGZpbGUubW96U2xpY2U7XG5cblx0XHRcdGlmICh1c2luZ0FzeW5jUmVhZGVyKVxuXHRcdFx0e1xuXHRcdFx0XHRyZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1x0XHQvLyBQcmVmZXJyZWQgbWV0aG9kIG9mIHJlYWRpbmcgZmlsZXMsIGV2ZW4gaW4gd29ya2Vyc1xuXHRcdFx0XHRyZWFkZXIub25sb2FkID0gYmluZEZ1bmN0aW9uKHRoaXMuX2NodW5rTG9hZGVkLCB0aGlzKTtcblx0XHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBiaW5kRnVuY3Rpb24odGhpcy5fY2h1bmtFcnJvciwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyU3luYygpO1x0Ly8gSGFjayBmb3IgcnVubmluZyBpbiBhIHdlYiB3b3JrZXIgaW4gRmlyZWZveFxuXG5cdFx0XHR0aGlzLl9uZXh0Q2h1bmsoKTtcdC8vIFN0YXJ0cyBzdHJlYW1pbmdcblx0XHR9O1xuXG5cdFx0dGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5fZmluaXNoZWQgJiYgKCF0aGlzLl9jb25maWcucHJldmlldyB8fCB0aGlzLl9yb3dDb3VudCA8IHRoaXMuX2NvbmZpZy5wcmV2aWV3KSlcblx0XHRcdFx0dGhpcy5fcmVhZENodW5rKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX3JlYWRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcblx0XHRcdGlmICh0aGlzLl9jb25maWcuY2h1bmtTaXplKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZW5kID0gTWF0aC5taW4odGhpcy5fc3RhcnQgKyB0aGlzLl9jb25maWcuY2h1bmtTaXplLCB0aGlzLl9pbnB1dC5zaXplKTtcblx0XHRcdFx0aW5wdXQgPSBzbGljZS5jYWxsKGlucHV0LCB0aGlzLl9zdGFydCwgZW5kKTtcblx0XHRcdH1cblx0XHRcdHZhciB0eHQgPSByZWFkZXIucmVhZEFzVGV4dChpbnB1dCwgdGhpcy5fY29uZmlnLmVuY29kaW5nKTtcblx0XHRcdGlmICghdXNpbmdBc3luY1JlYWRlcilcblx0XHRcdFx0dGhpcy5fY2h1bmtMb2FkZWQoeyB0YXJnZXQ6IHsgcmVzdWx0OiB0eHQgfSB9KTtcdC8vIG1pbWljIHRoZSBhc3luYyBzaWduYXR1cmVcblx0XHR9O1xuXG5cdFx0dGhpcy5fY2h1bmtMb2FkZWQgPSBmdW5jdGlvbihldmVudClcblx0XHR7XG5cdFx0XHQvLyBWZXJ5IGltcG9ydGFudCB0byBpbmNyZW1lbnQgc3RhcnQgZWFjaCB0aW1lIGJlZm9yZSBoYW5kbGluZyByZXN1bHRzXG5cdFx0XHR0aGlzLl9zdGFydCArPSB0aGlzLl9jb25maWcuY2h1bmtTaXplO1xuXHRcdFx0dGhpcy5fZmluaXNoZWQgPSAhdGhpcy5fY29uZmlnLmNodW5rU2l6ZSB8fCB0aGlzLl9zdGFydCA+PSB0aGlzLl9pbnB1dC5zaXplO1xuXHRcdFx0dGhpcy5wYXJzZUNodW5rKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuXHRcdH07XG5cblx0XHR0aGlzLl9jaHVua0Vycm9yID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihyZWFkZXIuZXJyb3IpO1xuXHRcdH07XG5cblx0fVxuXHRGaWxlU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaHVua1N0cmVhbWVyLnByb3RvdHlwZSk7XG5cdEZpbGVTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWxlU3RyZWFtZXI7XG5cblxuXHRmdW5jdGlvbiBTdHJpbmdTdHJlYW1lcihjb25maWcpXG5cdHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR2YXIgcmVtYWluaW5nO1xuXHRcdHRoaXMuc3RyZWFtID0gZnVuY3Rpb24ocylcblx0XHR7XG5cdFx0XHRyZW1haW5pbmcgPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXMuX25leHRDaHVuaygpO1xuXHRcdH07XG5cdFx0dGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9maW5pc2hlZCkgcmV0dXJuO1xuXHRcdFx0dmFyIHNpemUgPSB0aGlzLl9jb25maWcuY2h1bmtTaXplO1xuXHRcdFx0dmFyIGNodW5rO1xuXHRcdFx0aWYoc2l6ZSkge1xuXHRcdFx0XHRjaHVuayA9IHJlbWFpbmluZy5zdWJzdHJpbmcoMCwgc2l6ZSk7XG5cdFx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoc2l6ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHVuayA9IHJlbWFpbmluZztcblx0XHRcdFx0cmVtYWluaW5nID0gJyc7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9maW5pc2hlZCA9ICFyZW1haW5pbmc7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNodW5rKGNodW5rKTtcblx0XHR9O1xuXHR9XG5cdFN0cmluZ1N0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyaW5nU3RyZWFtZXIucHJvdG90eXBlKTtcblx0U3RyaW5nU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RyaW5nU3RyZWFtZXI7XG5cblxuXHRmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHRcdENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0dmFyIHBhcnNlT25EYXRhID0gdHJ1ZTtcblx0XHR2YXIgc3RyZWFtSGFzRW5kZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGF1c2UgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0Q2h1bmtTdHJlYW1lci5wcm90b3R5cGUucGF1c2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX2lucHV0LnBhdXNlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdENodW5rU3RyZWFtZXIucHJvdG90eXBlLnJlc3VtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5faW5wdXQucmVzdW1lKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKVxuXHRcdHtcblx0XHRcdHRoaXMuX2lucHV0ID0gc3RyZWFtO1xuXG5cdFx0XHR0aGlzLl9pbnB1dC5vbignZGF0YScsIHRoaXMuX3N0cmVhbURhdGEpO1xuXHRcdFx0dGhpcy5faW5wdXQub24oJ2VuZCcsIHRoaXMuX3N0cmVhbUVuZCk7XG5cdFx0XHR0aGlzLl9pbnB1dC5vbignZXJyb3InLCB0aGlzLl9zdHJlYW1FcnJvcik7XG5cdFx0fTtcblxuXHRcdHRoaXMuX2NoZWNrSXNGaW5pc2hlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAoc3RyZWFtSGFzRW5kZWQgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuX2NoZWNrSXNGaW5pc2hlZCgpO1xuXHRcdFx0aWYgKHF1ZXVlLmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5wYXJzZUNodW5rKHF1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRwYXJzZU9uRGF0YSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuX3N0cmVhbURhdGEgPSBiaW5kRnVuY3Rpb24oZnVuY3Rpb24oY2h1bmspXG5cdFx0e1xuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdHF1ZXVlLnB1c2godHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGNodW5rIDogY2h1bmsudG9TdHJpbmcodGhpcy5fY29uZmlnLmVuY29kaW5nKSk7XG5cblx0XHRcdFx0aWYgKHBhcnNlT25EYXRhKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGFyc2VPbkRhdGEgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLl9jaGVja0lzRmluaXNoZWQoKTtcblx0XHRcdFx0XHR0aGlzLnBhcnNlQ2h1bmsocXVldWUuc2hpZnQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnJvcilcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fc3RyZWFtRXJyb3IoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fc3RyZWFtRXJyb3IgPSBiaW5kRnVuY3Rpb24oZnVuY3Rpb24oZXJyb3IpXG5cdFx0e1xuXHRcdFx0dGhpcy5fc3RyZWFtQ2xlYW5VcCgpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGVycm9yKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX3N0cmVhbUVuZCA9IGJpbmRGdW5jdGlvbihmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5fc3RyZWFtQ2xlYW5VcCgpO1xuXHRcdFx0c3RyZWFtSGFzRW5kZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fc3RyZWFtRGF0YSgnJyk7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9zdHJlYW1DbGVhblVwID0gYmluZEZ1bmN0aW9uKGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLl9pbnB1dC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHRoaXMuX3N0cmVhbURhdGEpO1xuXHRcdFx0dGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHRoaXMuX3N0cmVhbUVuZCk7XG5cdFx0XHR0aGlzLl9pbnB1dC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9zdHJlYW1FcnJvcik7XG5cdFx0fSwgdGhpcyk7XG5cdH1cblx0UmVhZGFibGVTdHJlYW1TdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENodW5rU3RyZWFtZXIucHJvdG90eXBlKTtcblx0UmVhZGFibGVTdHJlYW1TdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyO1xuXG5cblx0ZnVuY3Rpb24gRHVwbGV4U3RyZWFtU3RyZWFtZXIoX2NvbmZpZykge1xuXHRcdHZhciBEdXBsZXggPSByZXF1aXJlKCdzdHJlYW0nKS5EdXBsZXg7XG5cdFx0dmFyIGNvbmZpZyA9IGNvcHkoX2NvbmZpZyk7XG5cdFx0dmFyIHBhcnNlT25Xcml0ZSA9IHRydWU7XG5cdFx0dmFyIHdyaXRlU3RyZWFtSGFzRmluaXNoZWQgPSBmYWxzZTtcblx0XHR2YXIgcGFyc2VDYWxsYmFja1F1ZXVlID0gW107XG5cdFx0dmFyIHN0cmVhbSA9IG51bGw7XG5cblx0XHR0aGlzLl9vbkNzdkRhdGEgPSBmdW5jdGlvbihyZXN1bHRzKVxuXHRcdHtcblx0XHRcdHZhciBkYXRhID0gcmVzdWx0cy5kYXRhO1xuXHRcdFx0aWYgKCFzdHJlYW0ucHVzaChkYXRhKSAmJiAhdGhpcy5faGFuZGxlLnBhdXNlZCgpKSB7XG5cdFx0XHRcdC8vIHRoZSB3cml0ZWFibGUgY29uc3VtZXIgYnVmZmVyIGhhcyBmaWxsZWQgdXBcblx0XHRcdFx0Ly8gc28gd2UgbmVlZCB0byBwYXVzZSB1bnRpbCBtb3JlIGl0ZW1zXG5cdFx0XHRcdC8vIGNhbiBiZSBwcm9jZXNzZWRcblx0XHRcdFx0dGhpcy5faGFuZGxlLnBhdXNlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuX29uQ3N2Q29tcGxldGUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0Ly8gbm9kZSB3aWxsIGZpbmlzaCB0aGUgcmVhZCBzdHJlYW0gd2hlblxuXHRcdFx0Ly8gbnVsbCBpcyBwdXNoZWRcblx0XHRcdHN0cmVhbS5wdXNoKG51bGwpO1xuXHRcdH07XG5cblx0XHRjb25maWcuc3RlcCA9IGJpbmRGdW5jdGlvbih0aGlzLl9vbkNzdkRhdGEsIHRoaXMpO1xuXHRcdGNvbmZpZy5jb21wbGV0ZSA9IGJpbmRGdW5jdGlvbih0aGlzLl9vbkNzdkNvbXBsZXRlLCB0aGlzKTtcblx0XHRDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAod3JpdGVTdHJlYW1IYXNGaW5pc2hlZCAmJiBwYXJzZUNhbGxiYWNrUXVldWUubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwYXJzZUNhbGxiYWNrUXVldWUubGVuZ3RoKSB7XG5cdFx0XHRcdHBhcnNlQ2FsbGJhY2tRdWV1ZS5zaGlmdCgpKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJzZU9uV3JpdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLl9hZGRUb1BhcnNlUXVldWUgPSBmdW5jdGlvbihjaHVuaywgY2FsbGJhY2spXG5cdFx0e1xuXHRcdFx0Ly8gYWRkIHRvIHF1ZXVlIHNvIHRoYXQgd2UgY2FuIGluZGljYXRlXG5cdFx0XHQvLyBjb21wbGV0aW9uIHZpYSBjYWxsYmFja1xuXHRcdFx0Ly8gbm9kZSB3aWxsIGF1dG9tYXRpY2FsbHkgcGF1c2UgdGhlIGluY29taW5nIHN0cmVhbVxuXHRcdFx0Ly8gd2hlbiB0b28gbWFueSBpdGVtcyBoYXZlIGJlZW4gYWRkZWQgd2l0aG91dCB0aGVpclxuXHRcdFx0Ly8gY2FsbGJhY2sgYmVpbmcgaW52b2tlZFxuXHRcdFx0cGFyc2VDYWxsYmFja1F1ZXVlLnB1c2goYmluZEZ1bmN0aW9uKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcnNlQ2h1bmsodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGNodW5rIDogY2h1bmsudG9TdHJpbmcoY29uZmlnLmVuY29kaW5nKSk7XG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRpZiAocGFyc2VPbldyaXRlKSB7XG5cdFx0XHRcdHBhcnNlT25Xcml0ZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9uZXh0Q2h1bmsoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fb25SZWFkID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9oYW5kbGUucGF1c2VkKCkpIHtcblx0XHRcdFx0Ly8gdGhlIHdyaXRlYWJsZSBjb25zdW1lciBjYW4gaGFuZGxlIG1vcmUgZGF0YVxuXHRcdFx0XHQvLyBzbyByZXN1bWUgdGhlIGNodW5rIHBhcnNpbmdcblx0XHRcdFx0dGhpcy5faGFuZGxlLnJlc3VtZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLl9vbldyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaylcblx0XHR7XG5cdFx0XHR0aGlzLl9hZGRUb1BhcnNlUXVldWUoY2h1bmssIGNhbGxiYWNrKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5fb25Xcml0ZUNvbXBsZXRlID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHdyaXRlU3RyZWFtSGFzRmluaXNoZWQgPSB0cnVlO1xuXHRcdFx0Ly8gaGF2ZSB0byB3cml0ZSBlbXB0eSBzdHJpbmdcblx0XHRcdC8vIHNvIHBhcnNlciBrbm93cyBpdHMgZG9uZVxuXHRcdFx0dGhpcy5fYWRkVG9QYXJzZVF1ZXVlKCcnKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTdHJlYW0gPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHN0cmVhbTtcblx0XHR9O1xuXHRcdHN0cmVhbSA9IG5ldyBEdXBsZXgoe1xuXHRcdFx0cmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuXHRcdFx0ZGVjb2RlU3RyaW5nczogZmFsc2UsXG5cdFx0XHRyZWFkOiBiaW5kRnVuY3Rpb24odGhpcy5fb25SZWFkLCB0aGlzKSxcblx0XHRcdHdyaXRlOiBiaW5kRnVuY3Rpb24odGhpcy5fb25Xcml0ZSwgdGhpcylcblx0XHR9KTtcblx0XHRzdHJlYW0ub25jZSgnZmluaXNoJywgYmluZEZ1bmN0aW9uKHRoaXMuX29uV3JpdGVDb21wbGV0ZSwgdGhpcykpO1xuXHR9XG5cdGlmICh0eXBlb2YgUEFQQV9CUk9XU0VSX0NPTlRFWFQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0RHVwbGV4U3RyZWFtU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaHVua1N0cmVhbWVyLnByb3RvdHlwZSk7XG5cdFx0RHVwbGV4U3RyZWFtU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHVwbGV4U3RyZWFtU3RyZWFtZXI7XG5cdH1cblxuXG5cdC8vIFVzZSBvbmUgUGFyc2VySGFuZGxlIHBlciBlbnRpcmUgQ1NWIGZpbGUgb3Igc3RyaW5nXG5cdGZ1bmN0aW9uIFBhcnNlckhhbmRsZShfY29uZmlnKVxuXHR7XG5cdFx0Ly8gT25lIGdvYWwgaXMgdG8gbWluaW1pemUgdGhlIHVzZSBvZiByZWd1bGFyIGV4cHJlc3Npb25zLi4uXG5cdFx0dmFyIE1BWF9GTE9BVCA9IE1hdGgucG93KDIsIDUzKTtcblx0XHR2YXIgTUlOX0ZMT0FUID0gLU1BWF9GTE9BVDtcblx0XHR2YXIgRkxPQVQgPSAvXlxccyotPyhcXGQrXFwuP3xcXC5cXGQrfFxcZCtcXC5cXGQrKShbZUVdWy0rXT9cXGQrKT9cXHMqJC87XG5cdFx0dmFyIElTT19EQVRFID0gL14oKFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkKyhbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpKSQvO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgX3N0ZXBDb3VudGVyID0gMDtcdC8vIE51bWJlciBvZiB0aW1lcyBzdGVwIHdhcyBjYWxsZWQgKG51bWJlciBvZiByb3dzIHBhcnNlZClcblx0XHR2YXIgX3Jvd0NvdW50ZXIgPSAwO1x0Ly8gTnVtYmVyIG9mIHJvd3MgdGhhdCBoYXZlIGJlZW4gcGFyc2VkIHNvIGZhclxuXHRcdHZhciBfaW5wdXQ7XHRcdFx0XHQvLyBUaGUgaW5wdXQgYmVpbmcgcGFyc2VkXG5cdFx0dmFyIF9wYXJzZXI7XHRcdFx0Ly8gVGhlIGNvcmUgcGFyc2VyIGJlaW5nIHVzZWRcblx0XHR2YXIgX3BhdXNlZCA9IGZhbHNlO1x0Ly8gV2hldGhlciB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuXHRcdHZhciBfYWJvcnRlZCA9IGZhbHNlO1x0Ly8gV2hldGhlciB0aGUgcGFyc2VyIGhhcyBhYm9ydGVkIG9yIG5vdFxuXHRcdHZhciBfZGVsaW1pdGVyRXJyb3I7XHQvLyBUZW1wb3Jhcnkgc3RhdGUgYmV0d2VlbiBkZWxpbWl0ZXIgZGV0ZWN0aW9uIGFuZCBwcm9jZXNzaW5nIHJlc3VsdHNcblx0XHR2YXIgX2ZpZWxkcyA9IFtdO1x0XHQvLyBGaWVsZHMgYXJlIGZyb20gdGhlIGhlYWRlciByb3cgb2YgdGhlIGlucHV0LCBpZiB0aGVyZSBpcyBvbmVcblx0XHR2YXIgX3Jlc3VsdHMgPSB7XHRcdC8vIFRoZSBsYXN0IHJlc3VsdHMgcmV0dXJuZWQgZnJvbSB0aGUgcGFyc2VyXG5cdFx0XHRkYXRhOiBbXSxcblx0XHRcdGVycm9yczogW10sXG5cdFx0XHRtZXRhOiB7fVxuXHRcdH07XG5cblx0XHRpZiAoaXNGdW5jdGlvbihfY29uZmlnLnN0ZXApKVxuXHRcdHtcblx0XHRcdHZhciB1c2VyU3RlcCA9IF9jb25maWcuc3RlcDtcblx0XHRcdF9jb25maWcuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdHMpXG5cdFx0XHR7XG5cdFx0XHRcdF9yZXN1bHRzID0gcmVzdWx0cztcblxuXHRcdFx0XHRpZiAobmVlZHNIZWFkZXJSb3coKSlcblx0XHRcdFx0XHRwcm9jZXNzUmVzdWx0cygpO1xuXHRcdFx0XHRlbHNlXHQvLyBvbmx5IGNhbGwgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYWZ0ZXIgaGVhZGVyIHJvd1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cHJvY2Vzc1Jlc3VsdHMoKTtcblxuXHRcdFx0XHRcdC8vIEl0J3MgcG9zc2JpbGUgdGhhdCB0aGlzIGxpbmUgd2FzIGVtcHR5IGFuZCB0aGVyZSdzIG5vIHJvdyBoZXJlIGFmdGVyIGFsbFxuXHRcdFx0XHRcdGlmIChfcmVzdWx0cy5kYXRhLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdF9zdGVwQ291bnRlciArPSByZXN1bHRzLmRhdGEubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChfY29uZmlnLnByZXZpZXcgJiYgX3N0ZXBDb3VudGVyID4gX2NvbmZpZy5wcmV2aWV3KVxuXHRcdFx0XHRcdFx0X3BhcnNlci5hYm9ydCgpO1xuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0X3Jlc3VsdHMuZGF0YSA9IF9yZXN1bHRzLmRhdGFbMF07XG5cdFx0XHRcdFx0XHR1c2VyU3RlcChfcmVzdWx0cywgc2VsZik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBpbnB1dC4gTW9zdCB1c2VycyB3b24ndCBuZWVkLCBhbmQgc2hvdWxkbid0IG1lc3Mgd2l0aCwgdGhlIGJhc2VJbmRleFxuXHRcdCAqIGFuZCBpZ25vcmVMYXN0Um93IHBhcmFtZXRlcnMuIFRoZXkgYXJlIHVzZWQgYnkgc3RyZWFtZXJzICh3cmFwcGVyIGZ1bmN0aW9ucylcblx0XHQgKiB3aGVuIGFuIGlucHV0IGNvbWVzIGluIG11bHRpcGxlIGNodW5rcywgbGlrZSBmcm9tIGEgZmlsZS5cblx0XHQgKi9cblx0XHR0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdylcblx0XHR7XG5cdFx0XHR2YXIgcXVvdGVDaGFyID0gX2NvbmZpZy5xdW90ZUNoYXIgfHwgJ1wiJztcblx0XHRcdGlmICghX2NvbmZpZy5uZXdsaW5lKVxuXHRcdFx0XHRfY29uZmlnLm5ld2xpbmUgPSB0aGlzLmd1ZXNzTGluZUVuZGluZ3MoaW5wdXQsIHF1b3RlQ2hhcik7XG5cblx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0aWYgKCFfY29uZmlnLmRlbGltaXRlcilcblx0XHRcdHtcblx0XHRcdFx0dmFyIGRlbGltR3Vlc3MgPSBndWVzc0RlbGltaXRlcihpbnB1dCwgX2NvbmZpZy5uZXdsaW5lLCBfY29uZmlnLnNraXBFbXB0eUxpbmVzLCBfY29uZmlnLmNvbW1lbnRzLCBfY29uZmlnLmRlbGltaXRlcnNUb0d1ZXNzKTtcblx0XHRcdFx0aWYgKGRlbGltR3Vlc3Muc3VjY2Vzc2Z1bClcblx0XHRcdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IGRlbGltR3Vlc3MuYmVzdERlbGltaXRlcjtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2RlbGltaXRlckVycm9yID0gdHJ1ZTtcdC8vIGFkZCBlcnJvciBhZnRlciBwYXJzaW5nIChvdGhlcndpc2UgaXQgd291bGQgYmUgb3ZlcndyaXR0ZW4pXG5cdFx0XHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBQYXBhLkRlZmF1bHREZWxpbWl0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoaXNGdW5jdGlvbihfY29uZmlnLmRlbGltaXRlcikpXG5cdFx0XHR7XG5cdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXIoaW5wdXQpO1xuXHRcdFx0XHRfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyc2VyQ29uZmlnID0gY29weShfY29uZmlnKTtcblx0XHRcdGlmIChfY29uZmlnLnByZXZpZXcgJiYgX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdHBhcnNlckNvbmZpZy5wcmV2aWV3Kys7XHQvLyB0byBjb21wZW5zYXRlIGZvciBoZWFkZXIgcm93XG5cblx0XHRcdF9pbnB1dCA9IGlucHV0O1xuXHRcdFx0X3BhcnNlciA9IG5ldyBQYXJzZXIocGFyc2VyQ29uZmlnKTtcblx0XHRcdF9yZXN1bHRzID0gX3BhcnNlci5wYXJzZShfaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdyk7XG5cdFx0XHRwcm9jZXNzUmVzdWx0cygpO1xuXHRcdFx0cmV0dXJuIF9wYXVzZWQgPyB7IG1ldGE6IHsgcGF1c2VkOiB0cnVlIH0gfSA6IChfcmVzdWx0cyB8fCB7IG1ldGE6IHsgcGF1c2VkOiBmYWxzZSB9IH0pO1xuXHRcdH07XG5cblx0XHR0aGlzLnBhdXNlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX3BhdXNlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5wYXVzZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfcGF1c2VkID0gdHJ1ZTtcblx0XHRcdF9wYXJzZXIuYWJvcnQoKTtcblxuXHRcdFx0Ly8gSWYgaXQgaXMgc3RyZWFtaW5nIHZpYSBcImNodW5raW5nXCIsIHRoZSByZWFkZXIgd2lsbCBzdGFydCBhcHBlbmRpbmcgY29ycmVjdGx5IGFscmVhZHkgc28gbm8gbmVlZCB0byBzdWJzdHJpbmcsXG5cdFx0XHQvLyBvdGhlcndpc2Ugd2UgY2FuIGdldCBkdXBsaWNhdGUgY29udGVudCB3aXRoaW4gYSByb3dcblx0XHRcdF9pbnB1dCA9IGlzRnVuY3Rpb24oX2NvbmZpZy5jaHVuaykgPyBcIlwiIDogX2lucHV0LnN1YnN0cmluZyhfcGFyc2VyLmdldENoYXJJbmRleCgpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYoc2VsZi5zdHJlYW1lci5faGFsdGVkKSB7XG5cdFx0XHRcdF9wYXVzZWQgPSBmYWxzZTtcblx0XHRcdFx0c2VsZi5zdHJlYW1lci5wYXJzZUNodW5rKF9pbnB1dCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBCdWdmaXg6ICM2MzYgSW4gY2FzZSB0aGUgcHJvY2Vzc2luZyBoYXNuJ3QgaGFsdGVkIHlldFxuXHRcdFx0XHQvLyB3YWl0IGZvciBpdCB0byBoYWx0IGluIG9yZGVyIHRvIHJlc3VtZVxuXHRcdFx0XHRzZXRUaW1lb3V0KHNlbGYucmVzdW1lLCAzKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5hYm9ydGVkID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBfYWJvcnRlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5hYm9ydCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRfYWJvcnRlZCA9IHRydWU7XG5cdFx0XHRfcGFyc2VyLmFib3J0KCk7XG5cdFx0XHRfcmVzdWx0cy5tZXRhLmFib3J0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5jb21wbGV0ZSkpXG5cdFx0XHRcdF9jb25maWcuY29tcGxldGUoX3Jlc3VsdHMpO1xuXHRcdFx0X2lucHV0ID0gJyc7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ3Vlc3NMaW5lRW5kaW5ncyA9IGZ1bmN0aW9uKGlucHV0LCBxdW90ZUNoYXIpXG5cdFx0e1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoMCwgMTAyNCAqIDEwMjQpO1x0Ly8gbWF4IGxlbmd0aCAxIE1CXG5cdFx0XHQvLyBSZXBsYWNlIGFsbCB0aGUgdGV4dCBpbnNpZGUgcXVvdGVzXG5cdFx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChxdW90ZUNoYXIpICsgJyhbXl0qPyknICsgZXNjYXBlUmVnRXhwKHF1b3RlQ2hhciksICdnbScpO1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKHJlLCAnJyk7XG5cblx0XHRcdHZhciByID0gaW5wdXQuc3BsaXQoJ1xccicpO1xuXG5cdFx0XHR2YXIgbiA9IGlucHV0LnNwbGl0KCdcXG4nKTtcblxuXHRcdFx0dmFyIG5BcHBlYXJzRmlyc3QgPSAobi5sZW5ndGggPiAxICYmIG5bMF0ubGVuZ3RoIDwgclswXS5sZW5ndGgpO1xuXG5cdFx0XHRpZiAoci5sZW5ndGggPT09IDEgfHwgbkFwcGVhcnNGaXJzdClcblx0XHRcdFx0cmV0dXJuICdcXG4nO1xuXG5cdFx0XHR2YXIgbnVtV2l0aE4gPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocltpXVswXSA9PT0gJ1xcbicpXG5cdFx0XHRcdFx0bnVtV2l0aE4rKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bVdpdGhOID49IHIubGVuZ3RoIC8gMiA/ICdcXHJcXG4nIDogJ1xccic7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRlc3RFbXB0eUxpbmUocykge1xuXHRcdFx0cmV0dXJuIF9jb25maWcuc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknID8gcy5qb2luKCcnKS50cmltKCkgPT09ICcnIDogcy5sZW5ndGggPT09IDEgJiYgc1swXS5sZW5ndGggPT09IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGVzdEZsb2F0KHMpIHtcblx0XHRcdGlmIChGTE9BVC50ZXN0KHMpKSB7XG5cdFx0XHRcdHZhciBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChzKTtcblx0XHRcdFx0aWYgKGZsb2F0VmFsdWUgPiBNSU5fRkxPQVQgJiYgZmxvYXRWYWx1ZSA8IE1BWF9GTE9BVCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdHMoKVxuXHRcdHtcblx0XHRcdGlmIChfcmVzdWx0cyAmJiBfZGVsaW1pdGVyRXJyb3IpXG5cdFx0XHR7XG5cdFx0XHRcdGFkZEVycm9yKCdEZWxpbWl0ZXInLCAnVW5kZXRlY3RhYmxlRGVsaW1pdGVyJywgJ1VuYWJsZSB0byBhdXRvLWRldGVjdCBkZWxpbWl0aW5nIGNoYXJhY3RlcjsgZGVmYXVsdGVkIHRvIFxcJycgKyBQYXBhLkRlZmF1bHREZWxpbWl0ZXIgKyAnXFwnJyk7XG5cdFx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2NvbmZpZy5za2lwRW1wdHlMaW5lcylcblx0XHRcdHtcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YSA9IF9yZXN1bHRzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRyZXR1cm4gIXRlc3RFbXB0eUxpbmUoZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVlZHNIZWFkZXJSb3coKSlcblx0XHRcdFx0ZmlsbEhlYWRlckZpZWxkcygpO1xuXG5cdFx0XHRyZXR1cm4gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24oKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZWVkc0hlYWRlclJvdygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9jb25maWcuaGVhZGVyICYmIF9maWVsZHMubGVuZ3RoID09PSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbGxIZWFkZXJGaWVsZHMoKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0ZnVuY3Rpb24gYWRkSGVhZGVyKGhlYWRlciwgaSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy50cmFuc2Zvcm1IZWFkZXIpKVxuXHRcdFx0XHRcdGhlYWRlciA9IF9jb25maWcudHJhbnNmb3JtSGVhZGVyKGhlYWRlciwgaSk7XG5cblx0XHRcdFx0X2ZpZWxkcy5wdXNoKGhlYWRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KF9yZXN1bHRzLmRhdGFbMF0pKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgbmVlZHNIZWFkZXJSb3coKSAmJiBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldLmZvckVhY2goYWRkSGVhZGVyKTtcblxuXHRcdFx0XHRfcmVzdWx0cy5kYXRhLnNwbGljZSgwLCAxKTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIF9yZXN1bHRzLmRhdGFbMF0gaXMgbm90IGFuIGFycmF5LCB3ZSBhcmUgaW4gYSBzdGVwIHdoZXJlIF9yZXN1bHRzLmRhdGEgaXMgdGhlIHJvdy5cblx0XHRcdGVsc2Vcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YS5mb3JFYWNoKGFkZEhlYWRlcik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2hvdWxkQXBwbHlEeW5hbWljVHlwaW5nKGZpZWxkKSB7XG5cdFx0XHQvLyBDYWNoZSBmdW5jdGlvbiB2YWx1ZXMgdG8gYXZvaWQgY2FsbGluZyBpdCBmb3IgZWFjaCByb3dcblx0XHRcdGlmIChfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiAmJiBfY29uZmlnLmR5bmFtaWNUeXBpbmdbZmllbGRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0X2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSA9IF9jb25maWcuZHluYW1pY1R5cGluZ0Z1bmN0aW9uKGZpZWxkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoX2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSB8fCBfY29uZmlnLmR5bmFtaWNUeXBpbmcpID09PSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRHluYW1pYyhmaWVsZCwgdmFsdWUpXG5cdFx0e1xuXHRcdFx0aWYgKHNob3VsZEFwcGx5RHluYW1pY1R5cGluZyhmaWVsZCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnVFJVRScpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAnRkFMU0UnKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0ZWxzZSBpZiAodGVzdEZsb2F0KHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdFx0XHRcdGVsc2UgaWYgKElTT19EQVRFLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gKHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24oKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMgfHwgKCFfY29uZmlnLmhlYWRlciAmJiAhX2NvbmZpZy5keW5hbWljVHlwaW5nICYmICFfY29uZmlnLnRyYW5zZm9ybSkpXG5cdFx0XHRcdHJldHVybiBfcmVzdWx0cztcblxuXHRcdFx0ZnVuY3Rpb24gcHJvY2Vzc1Jvdyhyb3dTb3VyY2UsIGkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByb3cgPSBfY29uZmlnLmhlYWRlciA/IHt9IDogW107XG5cblx0XHRcdFx0dmFyIGo7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCByb3dTb3VyY2UubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZmllbGQgPSBqO1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHJvd1NvdXJjZVtqXTtcblxuXHRcdFx0XHRcdGlmIChfY29uZmlnLmhlYWRlcilcblx0XHRcdFx0XHRcdGZpZWxkID0gaiA+PSBfZmllbGRzLmxlbmd0aCA/ICdfX3BhcnNlZF9leHRyYScgOiBfZmllbGRzW2pdO1xuXG5cdFx0XHRcdFx0aWYgKF9jb25maWcudHJhbnNmb3JtKVxuXHRcdFx0XHRcdFx0dmFsdWUgPSBfY29uZmlnLnRyYW5zZm9ybSh2YWx1ZSxmaWVsZCk7XG5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlRHluYW1pYyhmaWVsZCwgdmFsdWUpO1xuXG5cdFx0XHRcdFx0aWYgKGZpZWxkID09PSAnX19wYXJzZWRfZXh0cmEnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJvd1tmaWVsZF0gPSByb3dbZmllbGRdIHx8IFtdO1xuXHRcdFx0XHRcdFx0cm93W2ZpZWxkXS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cm93W2ZpZWxkXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaiA+IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoJ0ZpZWxkTWlzbWF0Y2gnLCAnVG9vTWFueUZpZWxkcycsICdUb28gbWFueSBmaWVsZHM6IGV4cGVjdGVkICcgKyBfZmllbGRzLmxlbmd0aCArICcgZmllbGRzIGJ1dCBwYXJzZWQgJyArIGosIF9yb3dDb3VudGVyICsgaSk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaiA8IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoJ0ZpZWxkTWlzbWF0Y2gnLCAnVG9vRmV3RmllbGRzJywgJ1RvbyBmZXcgZmllbGRzOiBleHBlY3RlZCAnICsgX2ZpZWxkcy5sZW5ndGggKyAnIGZpZWxkcyBidXQgcGFyc2VkICcgKyBqLCBfcm93Q291bnRlciArIGkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJvdztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluY3JlbWVudEJ5ID0gMTtcblx0XHRcdGlmICghX3Jlc3VsdHMuZGF0YS5sZW5ndGggfHwgQXJyYXkuaXNBcnJheShfcmVzdWx0cy5kYXRhWzBdKSlcblx0XHRcdHtcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YSA9IF9yZXN1bHRzLmRhdGEubWFwKHByb2Nlc3NSb3cpO1xuXHRcdFx0XHRpbmNyZW1lbnRCeSA9IF9yZXN1bHRzLmRhdGEubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfcmVzdWx0cy5kYXRhID0gcHJvY2Vzc1JvdyhfcmVzdWx0cy5kYXRhLCAwKTtcblxuXG5cdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIgJiYgX3Jlc3VsdHMubWV0YSlcblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5maWVsZHMgPSBfZmllbGRzO1xuXG5cdFx0XHRfcm93Q291bnRlciArPSBpbmNyZW1lbnRCeTtcblx0XHRcdHJldHVybiBfcmVzdWx0cztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBndWVzc0RlbGltaXRlcihpbnB1dCwgbmV3bGluZSwgc2tpcEVtcHR5TGluZXMsIGNvbW1lbnRzLCBkZWxpbWl0ZXJzVG9HdWVzcykge1xuXHRcdFx0dmFyIGJlc3REZWxpbSwgYmVzdERlbHRhLCBmaWVsZENvdW50UHJldlJvdywgbWF4RmllbGRDb3VudDtcblxuXHRcdFx0ZGVsaW1pdGVyc1RvR3Vlc3MgPSBkZWxpbWl0ZXJzVG9HdWVzcyB8fCBbJywnLCAnXFx0JywgJ3wnLCAnOycsIFBhcGEuUkVDT1JEX1NFUCwgUGFwYS5VTklUX1NFUF07XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVsaW1pdGVyc1RvR3Vlc3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGRlbGltID0gZGVsaW1pdGVyc1RvR3Vlc3NbaV07XG5cdFx0XHRcdHZhciBkZWx0YSA9IDAsIGF2Z0ZpZWxkQ291bnQgPSAwLCBlbXB0eUxpbmVzQ291bnQgPSAwO1xuXHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR2YXIgcHJldmlldyA9IG5ldyBQYXJzZXIoe1xuXHRcdFx0XHRcdGNvbW1lbnRzOiBjb21tZW50cyxcblx0XHRcdFx0XHRkZWxpbWl0ZXI6IGRlbGltLFxuXHRcdFx0XHRcdG5ld2xpbmU6IG5ld2xpbmUsXG5cdFx0XHRcdFx0cHJldmlldzogMTBcblx0XHRcdFx0fSkucGFyc2UoaW5wdXQpO1xuXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcHJldmlldy5kYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKHNraXBFbXB0eUxpbmVzICYmIHRlc3RFbXB0eUxpbmUocHJldmlldy5kYXRhW2pdKSkge1xuXHRcdFx0XHRcdFx0ZW1wdHlMaW5lc0NvdW50Kys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGZpZWxkQ291bnQgPSBwcmV2aWV3LmRhdGFbal0ubGVuZ3RoO1xuXHRcdFx0XHRcdGF2Z0ZpZWxkQ291bnQgKz0gZmllbGRDb3VudDtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZmllbGRDb3VudFByZXZSb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZmllbGRDb3VudCA+IDApIHtcblx0XHRcdFx0XHRcdGRlbHRhICs9IE1hdGguYWJzKGZpZWxkQ291bnQgLSBmaWVsZENvdW50UHJldlJvdyk7XG5cdFx0XHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByZXZpZXcuZGF0YS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGF2Z0ZpZWxkQ291bnQgLz0gKHByZXZpZXcuZGF0YS5sZW5ndGggLSBlbXB0eUxpbmVzQ291bnQpO1xuXG5cdFx0XHRcdGlmICgodHlwZW9mIGJlc3REZWx0YSA9PT0gJ3VuZGVmaW5lZCcgfHwgZGVsdGEgPD0gYmVzdERlbHRhKVxuXHRcdFx0XHRcdCYmICh0eXBlb2YgbWF4RmllbGRDb3VudCA9PT0gJ3VuZGVmaW5lZCcgfHwgYXZnRmllbGRDb3VudCA+IG1heEZpZWxkQ291bnQpICYmIGF2Z0ZpZWxkQ291bnQgPiAxLjk5KSB7XG5cdFx0XHRcdFx0YmVzdERlbHRhID0gZGVsdGE7XG5cdFx0XHRcdFx0YmVzdERlbGltID0gZGVsaW07XG5cdFx0XHRcdFx0bWF4RmllbGRDb3VudCA9IGF2Z0ZpZWxkQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBiZXN0RGVsaW07XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3NmdWw6ICEhYmVzdERlbGltLFxuXHRcdFx0XHRiZXN0RGVsaW1pdGVyOiBiZXN0RGVsaW1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkRXJyb3IodHlwZSwgY29kZSwgbXNnLCByb3cpXG5cdFx0e1xuXHRcdFx0dmFyIGVycm9yID0ge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRjb2RlOiBjb2RlLFxuXHRcdFx0XHRtZXNzYWdlOiBtc2dcblx0XHRcdH07XG5cdFx0XHRpZihyb3cgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRlcnJvci5yb3cgPSByb3c7XG5cdFx0XHR9XG5cdFx0XHRfcmVzdWx0cy5lcnJvcnMucHVzaChlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucyAqL1xuXHRmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKVxuXHR7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcblx0fVxuXG5cdC8qKiBUaGUgY29yZSBwYXJzZXIgaW1wbGVtZW50cyBzcGVlZHkgYW5kIGNvcnJlY3QgQ1NWIHBhcnNpbmcgKi9cblx0ZnVuY3Rpb24gUGFyc2VyKGNvbmZpZylcblx0e1xuXHRcdC8vIFVucGFjayB0aGUgY29uZmlnIG9iamVjdFxuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHR2YXIgZGVsaW0gPSBjb25maWcuZGVsaW1pdGVyO1xuXHRcdHZhciBuZXdsaW5lID0gY29uZmlnLm5ld2xpbmU7XG5cdFx0dmFyIGNvbW1lbnRzID0gY29uZmlnLmNvbW1lbnRzO1xuXHRcdHZhciBzdGVwID0gY29uZmlnLnN0ZXA7XG5cdFx0dmFyIHByZXZpZXcgPSBjb25maWcucHJldmlldztcblx0XHR2YXIgZmFzdE1vZGUgPSBjb25maWcuZmFzdE1vZGU7XG5cdFx0dmFyIHF1b3RlQ2hhcjtcblx0XHR2YXIgcmVuYW1lZEhlYWRlcnMgPSBudWxsO1xuXG5cdFx0aWYgKGNvbmZpZy5xdW90ZUNoYXIgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucXVvdGVDaGFyID09PSBudWxsKSB7XG5cdFx0XHRxdW90ZUNoYXIgPSAnXCInO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxdW90ZUNoYXIgPSBjb25maWcucXVvdGVDaGFyO1xuXHRcdH1cblx0XHR2YXIgZXNjYXBlQ2hhciA9IHF1b3RlQ2hhcjtcblx0XHRpZiAoY29uZmlnLmVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZXNjYXBlQ2hhciA9IGNvbmZpZy5lc2NhcGVDaGFyO1xuXHRcdH1cblxuXHRcdC8vIERlbGltaXRlciBtdXN0IGJlIHZhbGlkXG5cdFx0aWYgKHR5cGVvZiBkZWxpbSAhPT0gJ3N0cmluZydcblx0XHRcdHx8IFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihkZWxpbSkgPiAtMSlcblx0XHRcdGRlbGltID0gJywnO1xuXG5cdFx0Ly8gQ29tbWVudCBjaGFyYWN0ZXIgbXVzdCBiZSB2YWxpZFxuXHRcdGlmIChjb21tZW50cyA9PT0gZGVsaW0pXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvbW1lbnQgY2hhcmFjdGVyIHNhbWUgYXMgZGVsaW1pdGVyJyk7XG5cdFx0ZWxzZSBpZiAoY29tbWVudHMgPT09IHRydWUpXG5cdFx0XHRjb21tZW50cyA9ICcjJztcblx0XHRlbHNlIGlmICh0eXBlb2YgY29tbWVudHMgIT09ICdzdHJpbmcnXG5cdFx0XHR8fCBQYXBhLkJBRF9ERUxJTUlURVJTLmluZGV4T2YoY29tbWVudHMpID4gLTEpXG5cdFx0XHRjb21tZW50cyA9IGZhbHNlO1xuXG5cdFx0Ly8gTmV3bGluZSBtdXN0IGJlIHZhbGlkOiBcXHIsIFxcbiwgb3IgXFxyXFxuXG5cdFx0aWYgKG5ld2xpbmUgIT09ICdcXG4nICYmIG5ld2xpbmUgIT09ICdcXHInICYmIG5ld2xpbmUgIT09ICdcXHJcXG4nKVxuXHRcdFx0bmV3bGluZSA9ICdcXG4nO1xuXG5cdFx0Ly8gV2UncmUgZ29ubmEgbmVlZCB0aGVzZSBhdCB0aGUgUGFyc2VyIHNjb3BlXG5cdFx0dmFyIGN1cnNvciA9IDA7XG5cdFx0dmFyIGFib3J0ZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KVxuXHRcdHtcblx0XHRcdC8vIEZvciBzb21lIHJlYXNvbiwgaW4gQ2hyb21lLCB0aGlzIHNwZWVkcyB0aGluZ3MgdXAgKCE/KVxuXHRcdFx0aWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0XHQvLyBXZSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgc29tZSBvZiB0aGVzZSBldmVyeSB0aW1lIHBhcnNlKCkgaXMgY2FsbGVkLFxuXHRcdFx0Ly8gYnV0IGhhdmluZyB0aGVtIGluIGEgbW9yZSBsb2NhbCBzY29wZSBzZWVtcyB0byBwZXJmb3JtIGJldHRlclxuXHRcdFx0dmFyIGlucHV0TGVuID0gaW5wdXQubGVuZ3RoLFxuXHRcdFx0XHRkZWxpbUxlbiA9IGRlbGltLmxlbmd0aCxcblx0XHRcdFx0bmV3bGluZUxlbiA9IG5ld2xpbmUubGVuZ3RoLFxuXHRcdFx0XHRjb21tZW50c0xlbiA9IGNvbW1lbnRzLmxlbmd0aDtcblx0XHRcdHZhciBzdGVwSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oc3RlcCk7XG5cblx0XHRcdC8vIEVzdGFibGlzaCBzdGFydGluZyBzdGF0ZVxuXHRcdFx0Y3Vyc29yID0gMDtcblx0XHRcdHZhciBkYXRhID0gW10sIGVycm9ycyA9IFtdLCByb3cgPSBbXSwgbGFzdEN1cnNvciA9IDA7XG5cblx0XHRcdGlmICghaW5wdXQpXG5cdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cblx0XHRcdGlmIChmYXN0TW9kZSB8fCAoZmFzdE1vZGUgIT09IGZhbHNlICYmIGlucHV0LmluZGV4T2YocXVvdGVDaGFyKSA9PT0gLTEpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcm93cyA9IGlucHV0LnNwbGl0KG5ld2xpbmUpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXHRcdFx0XHRcdGN1cnNvciArPSByb3cubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYgKGkgIT09IHJvd3MubGVuZ3RoIC0gMSlcblx0XHRcdFx0XHRcdGN1cnNvciArPSBuZXdsaW5lLmxlbmd0aDtcblx0XHRcdFx0XHRlbHNlIGlmIChpZ25vcmVMYXN0Um93KVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRpZiAoY29tbWVudHMgJiYgcm93LnN1YnN0cmluZygwLCBjb21tZW50c0xlbikgPT09IGNvbW1lbnRzKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0XHRcdHB1c2hSb3cocm93LnNwbGl0KGRlbGltKSk7XG5cdFx0XHRcdFx0XHRkb1N0ZXAoKTtcblx0XHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRwdXNoUm93KHJvdy5zcGxpdChkZWxpbSkpO1xuXHRcdFx0XHRcdGlmIChwcmV2aWV3ICYmIGkgPj0gcHJldmlldylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YS5zbGljZSgwLCBwcmV2aWV3KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdHZhciBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdHZhciBxdW90ZUNoYXJSZWdleCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGVzY2FwZUNoYXIpICsgZXNjYXBlUmVnRXhwKHF1b3RlQ2hhciksICdnJyk7XG5cdFx0XHR2YXIgcXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgY3Vyc29yKTtcblxuXHRcdFx0Ly8gUGFyc2VyIGxvb3Bcblx0XHRcdGZvciAoOzspXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEZpZWxkIGhhcyBvcGVuaW5nIHF1b3RlXG5cdFx0XHRcdGlmIChpbnB1dFtjdXJzb3JdID09PSBxdW90ZUNoYXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBTdGFydCBvdXIgc2VhcmNoIGZvciB0aGUgY2xvc2luZyBxdW90ZSB3aGVyZSB0aGUgY3Vyc29yIGlzXG5cdFx0XHRcdFx0cXVvdGVTZWFyY2ggPSBjdXJzb3I7XG5cblx0XHRcdFx0XHQvLyBTa2lwIHRoZSBvcGVuaW5nIHF1b3RlXG5cdFx0XHRcdFx0Y3Vyc29yKys7XG5cblx0XHRcdFx0XHRmb3IgKDs7KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIEZpbmQgY2xvc2luZyBxdW90ZVxuXHRcdFx0XHRcdFx0cXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgcXVvdGVTZWFyY2ggKyAxKTtcblxuXHRcdFx0XHRcdFx0Ly9ObyBvdGhlciBxdW90ZXMgYXJlIGZvdW5kIC0gbm8gb3RoZXIgZGVsaW1pdGVyc1xuXHRcdFx0XHRcdFx0aWYgKHF1b3RlU2VhcmNoID09PSAtMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCFpZ25vcmVMYXN0Um93KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm8gY2xvc2luZyBxdW90ZS4uLiB3aGF0IGEgcGl0eVxuXHRcdFx0XHRcdFx0XHRcdGVycm9ycy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6ICdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29kZTogJ01pc3NpbmdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ1F1b3RlZCBmaWVsZCB1bnRlcm1pbmF0ZWQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm93OiBkYXRhLmxlbmd0aCxcdC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleDogY3Vyc29yXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZpbmlzaCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHF1b3RlIGF0IEVPRlxuXHRcdFx0XHRcdFx0aWYgKHF1b3RlU2VhcmNoID09PSBpbnB1dExlbiAtIDEpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmluaXNoKHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBxdW90ZSBpcyBlc2NhcGVkLCBpdCdzIHBhcnQgb2YgdGhlIGRhdGE7IHNraXAgaXRcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBxdW90ZSBjaGFyYWN0ZXIgaXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXIsIHRoZW4gY2hlY2sgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG5cdFx0XHRcdFx0XHRpZiAocXVvdGVDaGFyID09PSBlc2NhcGVDaGFyICYmICBpbnB1dFtxdW90ZVNlYXJjaCArIDFdID09PSBlc2NhcGVDaGFyKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRxdW90ZVNlYXJjaCsrO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHF1b3RlIGNoYXJhY3RlciBpcyBub3QgdGhlIGVzY2FwZSBjaGFyYWN0ZXIsIHRoZW4gY2hlY2sgaWYgdGhlIHByZXZpb3VzIGNoYXJhY3RlciB3YXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHRcdGlmIChxdW90ZUNoYXIgIT09IGVzY2FwZUNoYXIgJiYgcXVvdGVTZWFyY2ggIT09IDAgJiYgaW5wdXRbcXVvdGVTZWFyY2ggLSAxXSA9PT0gZXNjYXBlQ2hhcilcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmKG5leHREZWxpbSAhPT0gLTEgJiYgbmV4dERlbGltIDwgKHF1b3RlU2VhcmNoICsgMSkpIHtcblx0XHRcdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgKHF1b3RlU2VhcmNoICsgMSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYobmV4dE5ld2xpbmUgIT09IC0xICYmIG5leHROZXdsaW5lIDwgKHF1b3RlU2VhcmNoICsgMSkpIHtcblx0XHRcdFx0XHRcdFx0bmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIChxdW90ZVNlYXJjaCArIDEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENoZWNrIHVwIHRvIG5leHREZWxpbSBvciBuZXh0TmV3bGluZSwgd2hpY2hldmVyIGlzIGNsb3Nlc3Rcblx0XHRcdFx0XHRcdHZhciBjaGVja1VwVG8gPSBuZXh0TmV3bGluZSA9PT0gLTEgPyBuZXh0RGVsaW0gOiBNYXRoLm1pbihuZXh0RGVsaW0sIG5leHROZXdsaW5lKTtcblx0XHRcdFx0XHRcdHZhciBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgPSBleHRyYVNwYWNlcyhjaGVja1VwVG8pO1xuXG5cdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHF1b3RlIGZvbGxvd2VkIGJ5IGRlbGltaXRlciBvciAndW5uZWNlc3Nhcnkgc3BhY2VzICsgZGVsaW1pdGVyJ1xuXHRcdFx0XHRcdFx0aWYgKGlucHV0LnN1YnN0cihxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIsIGRlbGltTGVuKSA9PT0gZGVsaW0pXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpKTtcblx0XHRcdFx0XHRcdFx0Y3Vyc29yID0gcXVvdGVTZWFyY2ggKyAxICsgc3BhY2VzQmV0d2VlblF1b3RlQW5kRGVsaW1pdGVyICsgZGVsaW1MZW47XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgY2hhciBhZnRlciBmb2xsb3dpbmcgZGVsaW1pdGVyIGlzIG5vdCBxdW90ZUNoYXIsIHdlIGZpbmQgbmV4dCBxdW90ZSBjaGFyIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdGlmIChpbnB1dFtxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgKyBkZWxpbUxlbl0gIT09IHF1b3RlQ2hhcilcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHF1b3RlU2VhcmNoID0gaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIsIGN1cnNvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRcdFx0bmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgc3BhY2VzQmV0d2VlblF1b3RlQW5kTmV3TGluZSA9IGV4dHJhU3BhY2VzKG5leHROZXdsaW5lKTtcblxuXHRcdFx0XHRcdFx0Ly8gQ2xvc2luZyBxdW90ZSBmb2xsb3dlZCBieSBuZXdsaW5lIG9yICd1bm5lY2Vzc2FyeSBzcGFjZXMgKyBuZXdMaW5lJ1xuXHRcdFx0XHRcdFx0aWYgKGlucHV0LnN1YnN0cmluZyhxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lLCBxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lICsgbmV3bGluZUxlbikgPT09IG5ld2xpbmUpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpKTtcblx0XHRcdFx0XHRcdFx0c2F2ZVJvdyhxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lICsgbmV3bGluZUxlbik7XG5cdFx0XHRcdFx0XHRcdG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XHQvLyBiZWNhdXNlIHdlIG1heSBoYXZlIHNraXBwZWQgdGhlIG5leHREZWxpbSBpbiB0aGUgcXVvdGVkIGZpZWxkXG5cdFx0XHRcdFx0XHRcdHF1b3RlU2VhcmNoID0gaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIsIGN1cnNvcik7XHQvLyB3ZSBzZWFyY2ggZm9yIGZpcnN0IHF1b3RlIGluIG5leHQgbGluZVxuXG5cdFx0XHRcdFx0XHRcdGlmIChzdGVwSXNGdW5jdGlvbilcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2tzIGZvciB2YWxpZCBjbG9zaW5nIHF1b3RlcyBhcmUgY29tcGxldGUgKGVzY2FwZWQgcXVvdGVzIG9yIHF1b3RlIGZvbGxvd2VkIGJ5IEVPRi9kZWxpbWl0ZXIvbmV3bGluZSkgLS0gYXNzdW1lIHRoZXNlIHF1b3RlcyBhcmUgcGFydCBvZiBhbiBpbnZhbGlkIHRleHQgc3RyaW5nXG5cdFx0XHRcdFx0XHRlcnJvcnMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdRdW90ZXMnLFxuXHRcdFx0XHRcdFx0XHRjb2RlOiAnSW52YWxpZFF1b3RlcycsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdUcmFpbGluZyBxdW90ZSBvbiBxdW90ZWQgZmllbGQgaXMgbWFsZm9ybWVkJyxcblx0XHRcdFx0XHRcdFx0cm93OiBkYXRhLmxlbmd0aCxcdC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBjdXJzb3Jcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRxdW90ZVNlYXJjaCsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbW1lbnQgZm91bmQgYXQgc3RhcnQgb2YgbmV3IGxpbmVcblx0XHRcdFx0aWYgKGNvbW1lbnRzICYmIHJvdy5sZW5ndGggPT09IDAgJiYgaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgY3Vyc29yICsgY29tbWVudHNMZW4pID09PSBjb21tZW50cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChuZXh0TmV3bGluZSA9PT0gLTEpXHQvLyBDb21tZW50IGVuZHMgYXQgRU9GXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdGN1cnNvciA9IG5leHROZXdsaW5lICsgbmV3bGluZUxlbjtcblx0XHRcdFx0XHRuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdFx0XHRuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTmV4dCBkZWxpbWl0ZXIgY29tZXMgYmVmb3JlIG5leHQgbmV3bGluZSwgc28gd2UndmUgcmVhY2hlZCBlbmQgb2YgZmllbGRcblx0XHRcdFx0aWYgKG5leHREZWxpbSAhPT0gLTEgJiYgKG5leHREZWxpbSA8IG5leHROZXdsaW5lIHx8IG5leHROZXdsaW5lID09PSAtMSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyb3cucHVzaChpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBuZXh0RGVsaW0pKTtcblx0XHRcdFx0XHRjdXJzb3IgPSBuZXh0RGVsaW0gKyBkZWxpbUxlbjtcblx0XHRcdFx0XHQvLyB3ZSBsb29rIGZvciBuZXh0IGRlbGltaXRlciBjaGFyXG5cdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVuZCBvZiByb3dcblx0XHRcdFx0aWYgKG5leHROZXdsaW5lICE9PSAtMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIG5leHROZXdsaW5lKSk7XG5cdFx0XHRcdFx0c2F2ZVJvdyhuZXh0TmV3bGluZSArIG5ld2xpbmVMZW4pO1xuXG5cdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0aWYgKGFib3J0ZWQpXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldylcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZpbmlzaCgpO1xuXG5cblx0XHRcdGZ1bmN0aW9uIHB1c2hSb3cocm93KVxuXHRcdFx0e1xuXHRcdFx0XHRkYXRhLnB1c2gocm93KTtcblx0XHRcdFx0bGFzdEN1cnNvciA9IGN1cnNvcjtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG4gICAgICAgICAgICAgKiBjaGVja3MgaWYgdGhlcmUgYXJlIGV4dHJhIHNwYWNlcyBhZnRlciBjbG9zaW5nIHF1b3RlIGFuZCBnaXZlbiBpbmRleCB3aXRob3V0IGFueSB0ZXh0XG4gICAgICAgICAgICAgKiBpZiBZZXMsIHJldHVybnMgdGhlIG51bWJlciBvZiBzcGFjZXNcbiAgICAgICAgICAgICAqL1xuXHRcdFx0ZnVuY3Rpb24gZXh0cmFTcGFjZXMoaW5kZXgpIHtcblx0XHRcdFx0dmFyIHNwYWNlTGVuZ3RoID0gMDtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHZhciB0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4ID0gaW5wdXQuc3Vic3RyaW5nKHF1b3RlU2VhcmNoICsgMSwgaW5kZXgpO1xuXHRcdFx0XHRcdGlmICh0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4ICYmIHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXgudHJpbSgpID09PSAnJykge1xuXHRcdFx0XHRcdFx0c3BhY2VMZW5ndGggPSB0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4Lmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNwYWNlTGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGVuZHMgdGhlIHJlbWFpbmluZyBpbnB1dCBmcm9tIGN1cnNvciB0byB0aGUgZW5kIGludG9cblx0XHRcdCAqIHJvdywgc2F2ZXMgdGhlIHJvdywgY2FsbHMgc3RlcCwgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGZpbmlzaCh2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGlnbm9yZUxhc3RSb3cpXG5cdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdFx0dmFsdWUgPSBpbnB1dC5zdWJzdHJpbmcoY3Vyc29yKTtcblx0XHRcdFx0cm93LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjdXJzb3IgPSBpbnB1dExlbjtcdC8vIGltcG9ydGFudCBpbiBjYXNlIHBhcnNpbmcgaXMgcGF1c2VkXG5cdFx0XHRcdHB1c2hSb3cocm93KTtcblx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGVuZHMgdGhlIGN1cnJlbnQgcm93IHRvIHRoZSByZXN1bHRzLiBJdCBzZXRzIHRoZSBjdXJzb3Jcblx0XHRcdCAqIHRvIG5ld0N1cnNvciBhbmQgZmluZHMgdGhlIG5leHROZXdsaW5lLiBUaGUgY2FsbGVyIHNob3VsZFxuXHRcdFx0ICogdGFrZSBjYXJlIHRvIGV4ZWN1dGUgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYW5kIGNoZWNrIGZvclxuXHRcdFx0ICogcHJldmlldyBhbmQgZW5kIHBhcnNpbmcgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBzYXZlUm93KG5ld0N1cnNvcilcblx0XHRcdHtcblx0XHRcdFx0Y3Vyc29yID0gbmV3Q3Vyc29yO1xuXHRcdFx0XHRwdXNoUm93KHJvdyk7XG5cdFx0XHRcdHJvdyA9IFtdO1xuXHRcdFx0XHRuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdH1cblxuXHRcdFx0LyoqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHJlc3VsdHMsIGVycm9ycywgYW5kIG1ldGEuICovXG5cdFx0XHRmdW5jdGlvbiByZXR1cm5hYmxlKHN0b3BwZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjb25maWcuaGVhZGVyICYmICFiYXNlSW5kZXggJiYgZGF0YS5sZW5ndGgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBkYXRhWzBdO1xuXHRcdFx0XHRcdGNvbnN0IGhlYWRlckNvdW50ID0ge307IC8vIFRvIHRyYWNrIHRoZSBjb3VudCBvZiBlYWNoIGJhc2UgaGVhZGVyXG5cdFx0XHRcdFx0Y29uc3QgdXNlZEhlYWRlcnMgPSBuZXcgU2V0KHJlc3VsdCk7IC8vIFRvIHRyYWNrIHVzZWQgaGVhZGVycyBhbmQgYXZvaWQgZHVwbGljYXRlc1xuXHRcdFx0XHRcdGxldCBkdXBsaWNhdGVIZWFkZXJzID0gZmFsc2U7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0bGV0IGhlYWRlciA9IHJlc3VsdFtpXTtcblx0XHRcdFx0XHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy50cmFuc2Zvcm1IZWFkZXIpKVxuXHRcdFx0XHRcdFx0XHRoZWFkZXIgPSBjb25maWcudHJhbnNmb3JtSGVhZGVyKGhlYWRlciwgaSk7XG5cblx0XHRcdFx0XHRcdGlmICghaGVhZGVyQ291bnRbaGVhZGVyXSkge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJDb3VudFtoZWFkZXJdID0gMTtcblx0XHRcdFx0XHRcdFx0cmVzdWx0W2ldID0gaGVhZGVyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGV0IG5ld0hlYWRlcjtcblx0XHRcdFx0XHRcdFx0bGV0IHN1ZmZpeENvdW50ID0gaGVhZGVyQ291bnRbaGVhZGVyXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBGaW5kIGEgdW5pcXVlIG5ldyBoZWFkZXJcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdG5ld0hlYWRlciA9IGAke2hlYWRlcn1fJHtzdWZmaXhDb3VudH1gO1xuXHRcdFx0XHRcdFx0XHRcdHN1ZmZpeENvdW50Kys7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUgKHVzZWRIZWFkZXJzLmhhcyhuZXdIZWFkZXIpKTtcblxuXHRcdFx0XHRcdFx0XHR1c2VkSGVhZGVycy5hZGQobmV3SGVhZGVyKTsgLy8gTWFyayB0aGlzIG5ldyBIZWFkZXIgYXMgdXNlZFxuXHRcdFx0XHRcdFx0XHRyZXN1bHRbaV0gPSBuZXdIZWFkZXI7XG5cdFx0XHRcdFx0XHRcdGhlYWRlckNvdW50W2hlYWRlcl0rKztcblx0XHRcdFx0XHRcdFx0ZHVwbGljYXRlSGVhZGVycyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGlmIChyZW5hbWVkSGVhZGVycyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlbmFtZWRIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmVuYW1lZEhlYWRlcnNbbmV3SGVhZGVyXSA9IGhlYWRlcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dXNlZEhlYWRlcnMuYWRkKGhlYWRlcik7IC8vIEVuc3VyZSB0aGUgb3JpZ2luYWwgaGVhZGVyIGlzIG1hcmtlZCBhcyB1c2VkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkdXBsaWNhdGVIZWFkZXJzKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0R1cGxpY2F0ZSBoZWFkZXJzIGZvdW5kIGFuZCByZW5hbWVkLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdFx0ZXJyb3JzOiBlcnJvcnMsXG5cdFx0XHRcdFx0bWV0YToge1xuXHRcdFx0XHRcdFx0ZGVsaW1pdGVyOiBkZWxpbSxcblx0XHRcdFx0XHRcdGxpbmVicmVhazogbmV3bGluZSxcblx0XHRcdFx0XHRcdGFib3J0ZWQ6IGFib3J0ZWQsXG5cdFx0XHRcdFx0XHR0cnVuY2F0ZWQ6ICEhc3RvcHBlZCxcblx0XHRcdFx0XHRcdGN1cnNvcjogbGFzdEN1cnNvciArIChiYXNlSW5kZXggfHwgMCksXG5cdFx0XHRcdFx0XHRyZW5hbWVkSGVhZGVyczogcmVuYW1lZEhlYWRlcnNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8qKiBFeGVjdXRlcyB0aGUgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYW5kIHJlc2V0cyBkYXRhICYgZXJyb3JzLiAqL1xuXHRcdFx0ZnVuY3Rpb24gZG9TdGVwKClcblx0XHRcdHtcblx0XHRcdFx0c3RlcChyZXR1cm5hYmxlKCkpO1xuXHRcdFx0XHRkYXRhID0gW107XG5cdFx0XHRcdGVycm9ycyA9IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKiogU2V0cyB0aGUgYWJvcnQgZmxhZyAqL1xuXHRcdHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0YWJvcnRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKiBHZXRzIHRoZSBjdXJzb3IgcG9zaXRpb24gKi9cblx0XHR0aGlzLmdldENoYXJJbmRleCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gY3Vyc29yO1xuXHRcdH07XG5cdH1cblxuXG5cdGZ1bmN0aW9uIG5ld1dvcmtlcigpXG5cdHtcblx0XHRpZiAoIVBhcGEuV09SS0VSU19TVVBQT1JURUQpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgd29ya2VyVXJsID0gZ2V0V29ya2VyQmxvYigpO1xuXHRcdHZhciB3ID0gbmV3IGdsb2JhbC5Xb3JrZXIod29ya2VyVXJsKTtcblx0XHR3Lm9ubWVzc2FnZSA9IG1haW5UaHJlYWRSZWNlaXZlZE1lc3NhZ2U7XG5cdFx0dy5pZCA9IHdvcmtlcklkQ291bnRlcisrO1xuXHRcdHdvcmtlcnNbdy5pZF0gPSB3O1xuXHRcdHJldHVybiB3O1xuXHR9XG5cblx0LyoqIENhbGxiYWNrIHdoZW4gbWFpbiB0aHJlYWQgcmVjZWl2ZXMgYSBtZXNzYWdlICovXG5cdGZ1bmN0aW9uIG1haW5UaHJlYWRSZWNlaXZlZE1lc3NhZ2UoZSlcblx0e1xuXHRcdHZhciBtc2cgPSBlLmRhdGE7XG5cdFx0dmFyIHdvcmtlciA9IHdvcmtlcnNbbXNnLndvcmtlcklkXTtcblx0XHR2YXIgYWJvcnRlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKG1zZy5lcnJvcilcblx0XHRcdHdvcmtlci51c2VyRXJyb3IobXNnLmVycm9yLCBtc2cuZmlsZSk7XG5cdFx0ZWxzZSBpZiAobXNnLnJlc3VsdHMgJiYgbXNnLnJlc3VsdHMuZGF0YSlcblx0XHR7XG5cdFx0XHR2YXIgYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdGNvbXBsZXRlV29ya2VyKG1zZy53b3JrZXJJZCwgeyBkYXRhOiBbXSwgZXJyb3JzOiBbXSwgbWV0YTogeyBhYm9ydGVkOiB0cnVlIH0gfSk7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgaGFuZGxlID0ge1xuXHRcdFx0XHRhYm9ydDogYWJvcnQsXG5cdFx0XHRcdHBhdXNlOiBub3RJbXBsZW1lbnRlZCxcblx0XHRcdFx0cmVzdW1lOiBub3RJbXBsZW1lbnRlZFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGlzRnVuY3Rpb24od29ya2VyLnVzZXJTdGVwKSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtc2cucmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0d29ya2VyLnVzZXJTdGVwKHtcblx0XHRcdFx0XHRcdGRhdGE6IG1zZy5yZXN1bHRzLmRhdGFbaV0sXG5cdFx0XHRcdFx0XHRlcnJvcnM6IG1zZy5yZXN1bHRzLmVycm9ycyxcblx0XHRcdFx0XHRcdG1ldGE6IG1zZy5yZXN1bHRzLm1ldGFcblx0XHRcdFx0XHR9LCBoYW5kbGUpO1xuXHRcdFx0XHRcdGlmIChhYm9ydGVkKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIG1zZy5yZXN1bHRzO1x0Ly8gZnJlZSBtZW1vcnkgQVNBUFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXNGdW5jdGlvbih3b3JrZXIudXNlckNodW5rKSlcblx0XHRcdHtcblx0XHRcdFx0d29ya2VyLnVzZXJDaHVuayhtc2cucmVzdWx0cywgaGFuZGxlLCBtc2cuZmlsZSk7XG5cdFx0XHRcdGRlbGV0ZSBtc2cucmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobXNnLmZpbmlzaGVkICYmICFhYm9ydGVkKVxuXHRcdFx0Y29tcGxldGVXb3JrZXIobXNnLndvcmtlcklkLCBtc2cucmVzdWx0cyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wbGV0ZVdvcmtlcih3b3JrZXJJZCwgcmVzdWx0cykge1xuXHRcdHZhciB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXTtcblx0XHRpZiAoaXNGdW5jdGlvbih3b3JrZXIudXNlckNvbXBsZXRlKSlcblx0XHRcdHdvcmtlci51c2VyQ29tcGxldGUocmVzdWx0cyk7XG5cdFx0d29ya2VyLnRlcm1pbmF0ZSgpO1xuXHRcdGRlbGV0ZSB3b3JrZXJzW3dvcmtlcklkXTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xuXHR9XG5cblx0LyoqIENhbGxiYWNrIHdoZW4gd29ya2VyIHRocmVhZCByZWNlaXZlcyBhIG1lc3NhZ2UgKi9cblx0ZnVuY3Rpb24gd29ya2VyVGhyZWFkUmVjZWl2ZWRNZXNzYWdlKGUpXG5cdHtcblx0XHR2YXIgbXNnID0gZS5kYXRhO1xuXG5cdFx0aWYgKHR5cGVvZiBQYXBhLldPUktFUl9JRCA9PT0gJ3VuZGVmaW5lZCcgJiYgbXNnKVxuXHRcdFx0UGFwYS5XT1JLRVJfSUQgPSBtc2cud29ya2VySWQ7XG5cblx0XHRpZiAodHlwZW9mIG1zZy5pbnB1dCA9PT0gJ3N0cmluZycpXG5cdFx0e1xuXHRcdFx0Z2xvYmFsLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0d29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuXHRcdFx0XHRyZXN1bHRzOiBQYXBhLnBhcnNlKG1zZy5pbnB1dCwgbXNnLmNvbmZpZyksXG5cdFx0XHRcdGZpbmlzaGVkOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGdsb2JhbC5GaWxlICYmIG1zZy5pbnB1dCBpbnN0YW5jZW9mIEZpbGUpIHx8IG1zZy5pbnB1dCBpbnN0YW5jZW9mIE9iamVjdClcdC8vIHRoYW5rIHlvdSwgU2FmYXJpIChzZWUgaXNzdWUgIzEwNilcblx0XHR7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IFBhcGEucGFyc2UobXNnLmlucHV0LCBtc2cuY29uZmlnKTtcblx0XHRcdGlmIChyZXN1bHRzKVxuXHRcdFx0XHRnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRcdHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcblx0XHRcdFx0XHRyZXN1bHRzOiByZXN1bHRzLFxuXHRcdFx0XHRcdGZpbmlzaGVkOiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBNYWtlcyBhIGRlZXAgY29weSBvZiBhbiBhcnJheSBvciBvYmplY3QgKG1vc3RseSkgKi9cblx0ZnVuY3Rpb24gY29weShvYmopXG5cdHtcblx0XHRpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR2YXIgY3B5ID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcblx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKVxuXHRcdFx0Y3B5W2tleV0gPSBjb3B5KG9ialtrZXldKTtcblx0XHRyZXR1cm4gY3B5O1xuXHR9XG5cblx0ZnVuY3Rpb24gYmluZEZ1bmN0aW9uKGYsIHNlbGYpXG5cdHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IGYuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfTtcblx0fVxuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmMpXG5cdHtcblx0XHRyZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG5cdH1cblxuXHRyZXR1cm4gUGFwYTtcbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJQYXBhIiwibW9kdWxlRmFjdG9yeSIsImdsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJnZXRXb3JrZXJCbG9iIiwiVVJMIiwid2Via2l0VVJMIiwiY29kZSIsInRvU3RyaW5nIiwiQkxPQl9VUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwidHlwZSIsIklTX1dPUktFUiIsImRvY3VtZW50IiwicG9zdE1lc3NhZ2UiLCJJU19QQVBBX1dPUktFUiIsIndvcmtlcnMiLCJ3b3JrZXJJZENvdW50ZXIiLCJwYXJzZSIsIkNzdlRvSnNvbiIsInVucGFyc2UiLCJKc29uVG9Dc3YiLCJSRUNPUkRfU0VQIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiVU5JVF9TRVAiLCJCWVRFX09SREVSX01BUksiLCJCQURfREVMSU1JVEVSUyIsIldPUktFUlNfU1VQUE9SVEVEIiwiV29ya2VyIiwiTk9ERV9TVFJFQU1fSU5QVVQiLCJMb2NhbENodW5rU2l6ZSIsIlJlbW90ZUNodW5rU2l6ZSIsIkRlZmF1bHREZWxpbWl0ZXIiLCJQYXJzZXIiLCJQYXJzZXJIYW5kbGUiLCJOZXR3b3JrU3RyZWFtZXIiLCJGaWxlU3RyZWFtZXIiLCJTdHJpbmdTdHJlYW1lciIsIlJlYWRhYmxlU3RyZWFtU3RyZWFtZXIiLCJQQVBBX0JST1dTRVJfQ09OVEVYVCIsIkR1cGxleFN0cmVhbVN0cmVhbWVyIiwialF1ZXJ5IiwiJCIsImZuIiwib3B0aW9ucyIsImNvbmZpZyIsInF1ZXVlIiwiZWFjaCIsImlkeCIsInN1cHBvcnRlZCIsInByb3AiLCJ0b1VwcGVyQ2FzZSIsImF0dHIiLCJ0b0xvd2VyQ2FzZSIsIkZpbGVSZWFkZXIiLCJmaWxlcyIsImxlbmd0aCIsImkiLCJwdXNoIiwiZmlsZSIsImlucHV0RWxlbSIsImluc3RhbmNlQ29uZmlnIiwiZXh0ZW5kIiwicGFyc2VOZXh0RmlsZSIsImlzRnVuY3Rpb24iLCJjb21wbGV0ZSIsImYiLCJiZWZvcmUiLCJyZXR1cm5lZCIsImFjdGlvbiIsImVycm9yIiwicmVhc29uIiwiZmlsZUNvbXBsZXRlIiwidXNlckNvbXBsZXRlRnVuYyIsInJlc3VsdHMiLCJuYW1lIiwiZWxlbSIsInNwbGljZSIsIm9ubWVzc2FnZSIsIndvcmtlclRocmVhZFJlY2VpdmVkTWVzc2FnZSIsIl9pbnB1dCIsIl9jb25maWciLCJkeW5hbWljVHlwaW5nIiwiZHluYW1pY1R5cGluZ0Z1bmN0aW9uIiwidHJhbnNmb3JtIiwid29ya2VyIiwidyIsIm5ld1dvcmtlciIsInVzZXJTdGVwIiwic3RlcCIsInVzZXJDaHVuayIsImNodW5rIiwidXNlckNvbXBsZXRlIiwidXNlckVycm9yIiwiaW5wdXQiLCJ3b3JrZXJJZCIsImlkIiwic3RyZWFtZXIiLCJnZXRTdHJlYW0iLCJzdHJpcEJvbSIsImRvd25sb2FkIiwicmVhZGFibGUiLCJyZWFkIiwib24iLCJGaWxlIiwiT2JqZWN0Iiwic3RyZWFtIiwic3RyaW5nIiwiY2hhckNvZGVBdCIsInNsaWNlIiwiX3F1b3RlcyIsIl93cml0ZUhlYWRlciIsIl9kZWxpbWl0ZXIiLCJfbmV3bGluZSIsIl9xdW90ZUNoYXIiLCJfZXNjYXBlZFF1b3RlIiwiX3NraXBFbXB0eUxpbmVzIiwiX2NvbHVtbnMiLCJfZXNjYXBlRm9ybXVsYWUiLCJ1bnBhY2tDb25maWciLCJxdW90ZUNoYXJSZWdleCIsIlJlZ0V4cCIsImVzY2FwZVJlZ0V4cCIsIkpTT04iLCJBcnJheSIsImlzQXJyYXkiLCJzZXJpYWxpemUiLCJrZXlzIiwiZGF0YSIsImZpZWxkcyIsIm1ldGEiLCJFcnJvciIsImRlbGltaXRlciIsImZpbHRlciIsInZhbHVlIiwiaW5kZXhPZiIsInF1b3RlcyIsInNraXBFbXB0eUxpbmVzIiwibmV3bGluZSIsInF1b3RlQ2hhciIsImhlYWRlciIsImNvbHVtbnMiLCJlc2NhcGVDaGFyIiwidW5kZWZpbmVkIiwiZXNjYXBlRm9ybXVsYWUiLCJjc3YiLCJoYXNIZWFkZXIiLCJkYXRhS2V5ZWRCeUZpZWxkIiwic2FmZSIsInJvdyIsIm1heENvbCIsImVtcHR5TGluZSIsIm51bGxMaW5lIiwiam9pbiIsInRyaW0iLCJsaW5lIiwiYyIsImN4IiwiY29sIiwiY29sSWR4Iiwic3RyIiwiY29uc3RydWN0b3IiLCJEYXRlIiwic3RyaW5naWZ5IiwibmVlZHNRdW90ZXMiLCJ0ZXN0IiwiZXNjYXBlZFF1b3RlU3RyIiwicmVwbGFjZSIsImhhc0FueSIsImNoYXJBdCIsInN1YnN0cmluZ3MiLCJDaHVua1N0cmVhbWVyIiwiX2hhbmRsZSIsIl9maW5pc2hlZCIsIl9jb21wbGV0ZWQiLCJfaGFsdGVkIiwiX2Jhc2VJbmRleCIsIl9wYXJ0aWFsTGluZSIsIl9yb3dDb3VudCIsIl9zdGFydCIsIl9uZXh0Q2h1bmsiLCJpc0ZpcnN0Q2h1bmsiLCJfY29tcGxldGVSZXN1bHRzIiwiZXJyb3JzIiwicmVwbGFjZUNvbmZpZyIsImNhbGwiLCJwYXJzZUNodW5rIiwiaXNGYWtlQ2h1bmsiLCJza2lwRmlyc3ROTGluZXMiLCJwYXJzZUludCIsImd1ZXNzTGluZUVuZGluZ3MiLCJzcGxpdENodW5rIiwic3BsaXQiLCJiZWZvcmVGaXJzdENodW5rIiwibW9kaWZpZWRDaHVuayIsImFnZ3JlZ2F0ZSIsInBhdXNlZCIsImFib3J0ZWQiLCJsYXN0SW5kZXgiLCJjdXJzb3IiLCJzdWJzdHJpbmciLCJmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXciLCJwcmV2aWV3IiwiV09SS0VSX0lEIiwiZmluaXNoZWQiLCJjb25jYXQiLCJfc2VuZEVycm9yIiwiY29uZmlnQ29weSIsImNvcHkiLCJjaHVua1NpemUiLCJ4aHIiLCJfcmVhZENodW5rIiwiX2NodW5rTG9hZGVkIiwidXJsIiwiWE1MSHR0cFJlcXVlc3QiLCJ3aXRoQ3JlZGVudGlhbHMiLCJvbmxvYWQiLCJiaW5kRnVuY3Rpb24iLCJvbmVycm9yIiwiX2NodW5rRXJyb3IiLCJvcGVuIiwiZG93bmxvYWRSZXF1ZXN0Qm9keSIsImRvd25sb2FkUmVxdWVzdEhlYWRlcnMiLCJoZWFkZXJzIiwiaGVhZGVyTmFtZSIsInNldFJlcXVlc3RIZWFkZXIiLCJlbmQiLCJzZW5kIiwiZXJyIiwibWVzc2FnZSIsInN0YXR1cyIsInJlYWR5U3RhdGUiLCJyZXNwb25zZVRleHQiLCJnZXRGaWxlU2l6ZSIsImVycm9yTWVzc2FnZSIsImVycm9yVGV4dCIsInN0YXR1c1RleHQiLCJjb250ZW50UmFuZ2UiLCJnZXRSZXNwb25zZUhlYWRlciIsImxhc3RJbmRleE9mIiwicHJvdG90eXBlIiwiY3JlYXRlIiwicmVhZGVyIiwidXNpbmdBc3luY1JlYWRlciIsIndlYmtpdFNsaWNlIiwibW96U2xpY2UiLCJGaWxlUmVhZGVyU3luYyIsIk1hdGgiLCJtaW4iLCJzaXplIiwidHh0IiwicmVhZEFzVGV4dCIsImVuY29kaW5nIiwidGFyZ2V0IiwicmVzdWx0IiwiZXZlbnQiLCJyZW1haW5pbmciLCJzIiwicGFyc2VPbkRhdGEiLCJzdHJlYW1IYXNFbmRlZCIsInBhdXNlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJyZXN1bWUiLCJfc3RyZWFtRGF0YSIsIl9zdHJlYW1FbmQiLCJfc3RyZWFtRXJyb3IiLCJfY2hlY2tJc0ZpbmlzaGVkIiwic2hpZnQiLCJfc3RyZWFtQ2xlYW5VcCIsInJlbW92ZUxpc3RlbmVyIiwiRHVwbGV4IiwicmVxdWlyZSIsInBhcnNlT25Xcml0ZSIsIndyaXRlU3RyZWFtSGFzRmluaXNoZWQiLCJwYXJzZUNhbGxiYWNrUXVldWUiLCJfb25Dc3ZEYXRhIiwiX29uQ3N2Q29tcGxldGUiLCJfYWRkVG9QYXJzZVF1ZXVlIiwiY2FsbGJhY2siLCJfb25SZWFkIiwiX29uV3JpdGUiLCJfb25Xcml0ZUNvbXBsZXRlIiwicmVhZGFibGVPYmplY3RNb2RlIiwiZGVjb2RlU3RyaW5ncyIsIndyaXRlIiwib25jZSIsIk1BWF9GTE9BVCIsInBvdyIsIk1JTl9GTE9BVCIsIkZMT0FUIiwiSVNPX0RBVEUiLCJfc3RlcENvdW50ZXIiLCJfcm93Q291bnRlciIsIl9wYXJzZXIiLCJfcGF1c2VkIiwiX2Fib3J0ZWQiLCJfZGVsaW1pdGVyRXJyb3IiLCJfZmllbGRzIiwiX3Jlc3VsdHMiLCJuZWVkc0hlYWRlclJvdyIsInByb2Nlc3NSZXN1bHRzIiwiYWJvcnQiLCJiYXNlSW5kZXgiLCJpZ25vcmVMYXN0Um93IiwiZGVsaW1HdWVzcyIsImd1ZXNzRGVsaW1pdGVyIiwiY29tbWVudHMiLCJkZWxpbWl0ZXJzVG9HdWVzcyIsInN1Y2Nlc3NmdWwiLCJiZXN0RGVsaW1pdGVyIiwicGFyc2VyQ29uZmlnIiwiZ2V0Q2hhckluZGV4Iiwic2V0VGltZW91dCIsInJlIiwiciIsIm4iLCJuQXBwZWFyc0ZpcnN0IiwibnVtV2l0aE4iLCJ0ZXN0RW1wdHlMaW5lIiwidGVzdEZsb2F0IiwiZmxvYXRWYWx1ZSIsInBhcnNlRmxvYXQiLCJhZGRFcnJvciIsImQiLCJmaWxsSGVhZGVyRmllbGRzIiwiYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24iLCJhZGRIZWFkZXIiLCJ0cmFuc2Zvcm1IZWFkZXIiLCJmb3JFYWNoIiwic2hvdWxkQXBwbHlEeW5hbWljVHlwaW5nIiwiZmllbGQiLCJwYXJzZUR5bmFtaWMiLCJwcm9jZXNzUm93Iiwicm93U291cmNlIiwiaiIsImluY3JlbWVudEJ5IiwibWFwIiwiYmVzdERlbGltIiwiYmVzdERlbHRhIiwiZmllbGRDb3VudFByZXZSb3ciLCJtYXhGaWVsZENvdW50IiwiZGVsaW0iLCJkZWx0YSIsImF2Z0ZpZWxkQ291bnQiLCJlbXB0eUxpbmVzQ291bnQiLCJmaWVsZENvdW50IiwiYWJzIiwibXNnIiwiZmFzdE1vZGUiLCJyZW5hbWVkSGVhZGVycyIsImlucHV0TGVuIiwiZGVsaW1MZW4iLCJuZXdsaW5lTGVuIiwiY29tbWVudHNMZW4iLCJzdGVwSXNGdW5jdGlvbiIsImxhc3RDdXJzb3IiLCJyZXR1cm5hYmxlIiwicm93cyIsInB1c2hSb3ciLCJkb1N0ZXAiLCJuZXh0RGVsaW0iLCJuZXh0TmV3bGluZSIsInF1b3RlU2VhcmNoIiwiaW5kZXgiLCJmaW5pc2giLCJjaGVja1VwVG8iLCJzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIiLCJleHRyYVNwYWNlcyIsInN1YnN0ciIsInNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUiLCJzYXZlUm93Iiwic3BhY2VMZW5ndGgiLCJ0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4IiwibmV3Q3Vyc29yIiwic3RvcHBlZCIsImhlYWRlckNvdW50IiwidXNlZEhlYWRlcnMiLCJTZXQiLCJkdXBsaWNhdGVIZWFkZXJzIiwibmV3SGVhZGVyIiwic3VmZml4Q291bnQiLCJoYXMiLCJhZGQiLCJjb25zb2xlIiwid2FybiIsImxpbmVicmVhayIsInRydW5jYXRlZCIsIndvcmtlclVybCIsIm1haW5UaHJlYWRSZWNlaXZlZE1lc3NhZ2UiLCJlIiwiY29tcGxldGVXb3JrZXIiLCJoYW5kbGUiLCJub3RJbXBsZW1lbnRlZCIsInRlcm1pbmF0ZSIsIm9iaiIsImNweSIsImtleSIsImZ1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/papaparse@5.5.1/node_modules/papaparse/papaparse.js\n");

/***/ })

};
;